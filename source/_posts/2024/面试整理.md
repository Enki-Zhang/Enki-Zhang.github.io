---
title: 面试整理
top: false
cover: false
toc: true
mathjax: true
date: 2024-01-17 14:46:53
password:
summary:
tags:
categories:
---

## 自我介绍

面试官您好，我是 2024 届汕头大学计算机技术专业的硕士研究生，本科就读于 安徽工程大学的软件工程专业，在本科阶段和研究生阶段我获得过多次奖学金并通过了六级考试，同时发表了一篇 sci 论文，在专业知识方面我深入了解过 Java 集合并发编程，MySQL、Redis 等相关的内容，今年的六月到九月我在亚信科技做过 Java 开发实习生的工作（实习经历），所在部门负责中国移动 APP 拉端搜索相关业务的开发，之前还做过一个关于学生抢座和博客分享方面的项目。在简历投递之前我了解到咱们公司是从事互联网金融信息相关的内容，拥有强大的创新能力和丰富的业务经验，对此我非常希望能够得到在这里学习和成长的机会，并继续从事 Java 开发方向的工作。那么这里的我的自我介绍完毕。

# 实习

## 问题

- 敏感词过滤
  DFA

  1.  树的根节点不存储数据，其他节点存储一个字符；2) 从根节点到叶节点的路径上的字符连接起来组成一个词。因此前缀相同的词语使用同一个分支，搜索时从词语的第一个字符开始查找对应的分支，能够显著地减少字符串比较，降低算法复杂度。
      对处理后的文本进行敏感词检测过滤，将检测到的敏感词用符号“\*”进行替换，检测算法基于 DFA 匹配模式，采用最小匹配规则

```java
/**
* 过滤敏感词，并把敏感词替换为指定字符
* @author hoojo
* @createDate 2018年2月9日 下午4:38:12
* @param partMatch 是否部分匹配
* @param content 被匹配的语句
* @param replaceChar 替换字符
* @return 过滤后的字符串
* @throws RuntimeException
*/
public String filter(boolean partMatch, String content, char replaceChar) throws RuntimeException;
```

- 深分页问题
  limit 100000,10 扫描更多的行数，也意味着回表更多的次数。而前 10 万次回表的数据都是无效的

解决：，
子查询优化，通过子查询拿到聚簇索引需要的主键，省去了不断回表的过程，然后第二查询直接根据第一个查询的 ID 往后再去查 10 个就可以了
`SELECT MCS_PROD_ID,MCS_CODE,MCS_NAME 
FROM MCS_PROD 
WHERE 
MCS_PROD_ID >= ( 
  SELECT m1.MCS_PROD_ID FROM MCS_PROD m1 
  WHERE m1.UPDT_TIME >= '1970-01-01 00:00:00.0' 
  ORDER BY m1.UPDT_TIME 
  LIMIT 3000000, 1) 
  LIMIT 1;`

- Java 查询数据库千万条数据内存溢出问题

## 服务调用的方式

Feign 是一个声明式的 http 客户端，作用是帮助我们优雅的实现 http 请求的发送，解决 RestTemplate 复杂 URL 的问题

# 项目

### 讲一下项目的整体，从设计思路、背景、框架、流程、核心技术、完成的工作、哪方面技术做的比较困难或者比较好这些方面来整体讲一下

![asset_img](八股-项目/2023-10-16-22-54-27.png)
架构图
https://tianweichang.blog.csdn.net/article/details/120170388?spm=1001.2101.3001.6650.14&utm_medium=distribute.pc_relevant.none-task-blog-2%7Edefault%7ECTRLIST%7ERate-14-120170388-blog-128361733.235%5Ev38%5Epc_relevant_anti_vip_base&depth_1-utm_source=distribute.pc_relevant.none-task-blog-2%7Edefault%7ECTRLIST%7ERate-14-120170388-blog-128361733.235%5Ev38%5Epc_relevant_anti_vip_base&utm_relevant_index=15

## 项目描述

这是一个模拟了高并发场景的抢票系统，它具备登陆和抢购的功能，并在经过几个版本的迭代之后成为支持高并发的抢票系统。为了解决用户抢购场景下的高并发问题。登陆部分通过两次 MD5 加密防止前端明文传输，和后端保证用户数据安全，同时引入了 redis 作为缓存中间件，主要作用是 完成 sessionID 的共享，缓存预热、预减库存等等。针对抢购进行了接口限流 、redis 预减库存，消息队列异步消费，请求路径动态创建等优化。通过 Jmeter 压力测试，系统的 QPS 从 150/s 提升到 2000/s。

## 秒杀流程

![asset_img](面试整理/2024-01-20-15-42-27.png)

## 登陆

用户密码两次 MD5 加密

### 加密算法

第一次 （在前端加密，客户端）：密码加密是（明文密码+固定盐值）生成 md5 用于传输，目的，由于 http 是明文传输，当输入密码若直接发送服务端验证，此时被截取将直接获取到明文密码，获取用户信息。

第二次（服务端）：当获取到前端发送来的密码后。通过 MD5（密码+随机盐值）再次生成密码后存入数据库。

### 分布式 sessionID

后端通过验证用户账号密码都正确情况下，通过 UUID 生成唯一 id 作为 token，再将 token 作为 key、用户信息对象作为 value 存储到 Redis，同时将 token 存储到 cookie，维持会话状态。当用户访问接口时，只需从 cookie 取出对应的 token 信息，根据 token 键值从 Redis 获取用户对象。并这是 token 的过期时间，当用户在期限内继续登陆会进行延长有效期。

### Web 项目防止同一账号在不同 session 下重复登录原创

Spring security 就可以防止用户重复登录。

## 订单唯一

UUID/雪花算法 userid+keyid

## 下单流程

- 超卖
  乐观锁：添加版本号
  每扣减一次就更改一下版本号，每次进行扣减之前需要查询一下版本号，只有在扣减时的版本号和之前的版本号相同时，才进行扣减。

### 分布式锁

解决超卖和重复下单

分布式锁满足集群模式下的重复超卖，主要应用到的是 SETNX key value 命令如果不存在，则设置

### 下单保证原子性

开启 Spring 事务功能

- Spring 事务失效

方法不是 public @Transactional 只能用于 public 的方法
异常被手动捕获，未抛出不能回滚
注解所在的类是否被 spring 管理
同一个类中调用其他方法 在类上加上 Transactional 注入自己

### 内存标记 + Redis 预减库存 + RabbitMQ 异步处理

（1）在用户发起秒杀访问时，先访问本地已经初始化好的 map，看当前秒杀商品 id 的库存是否已售罄，若已售罄，直接返回秒杀结束异常；若库存还有，在执行下面的操作。通过内存标记可以减少对后面步骤中的 Redis 访问操作，降低 Redis 的压力，不然每个请求都将访问一次 Redis。

（2）系统启动时，即将商品和库存数据初始化到 redis 中（通过实现 InitializingBean 接口的 afterPropertiesSet 方法），所有的抢购操作都在 Redis 中进行处理，通过 Redis 预减少库存来减少数据库访问。SpringBoot 启动后实现自动执行其它业务方法功能

（3）通过使用 RabbitMQ 用异步队列处理下单，实现系统高响应。此处响应客户端后，一般都是抢购成功了，当然不排除例外，此时客户端通过 ajax 请求轮询访问下单结果接口，直到响应状态成功或者失败。

### Redis 预减库存

主要思路减少对数据库的访问，不需要直接访问数据库，当高并发请求到来的时候，大量的读取数据有可能会导致数据库的崩溃

1. 系统初始化的时候，将商品库存加载到 Redis 缓存中保存
2. 收到请求的时候,先在 Redis 中拿到该商品的库存值，进行库存预减，如果减完之后库存不足，直接返回逻辑 Exception 就不需要访问数据库再去减库存了，如果库存值正确，进行下一步
   将请求入队，立即给前端返回一个值，表示正在排队中，然后进行下单逻辑，后端队列进行下单，前端轮询后端发来的请求，如果秒杀成功，返回秒杀，成功，不成功就返回失败。

### RabbitMq 异步下单

执行流程：

1. 系统初始化将商品数量加载到 Redis 中
2. 后端收到秒杀请求后，先在 redis 中预减库存，提前判断如果库存数量不足则返回秒杀失败，从而直接截断了后续请求。
3. 否则判断这个秒杀订单是否形成，判断是否已经秒杀到了，避免一个账户秒杀多个商品
4. 秒杀单形成并且库存充足无重复秒杀，将秒杀请求封装后放入消息队列，同时返回前端秒杀标识 ，前端接收到数据后，显示排队中，并根据商品 id 轮询请求服务器（200ms 轮询一次。
5. 后端 RabbitMQ 监听秒杀 MIAOSHA_QUEUE 的这个名字的通道，如果有消息过来就获取到传入的信息，执行真正的秒杀之前，要判断数据库的库存，判断是否重复秒杀，然后执行秒杀事务（秒杀事务是一个原子操作：库存减 1，下订单、写入订单详情）

### 如果 redis 预减库存成功，后边下单失败，怎么保证 redis 和 mysql 的一致性呢

mq 事务性消息，保证同时成功失败

### 解决超卖

1. 更新的 sql 语句，只有当库存大于 0 才能更新库存， 或者通过对库存字段设置为无符号型 那么出现负数则报错。
2. 对用户 id 和商品 id 建立一个唯一索引，通过这种约束避免同一用户发同时两个请求秒杀到两件相同商品

### 分布式锁

实现分布式情况下多线程互斥效果，为了防止超卖和重复下单 当线程过来请求
利用 SetNx 添加过期时间防止死锁，但是过期时间如何评估，
分布式锁误删：
（a 线程阻塞后，超时释放锁，b 线程拿到锁后 a 线程继续执行到删除锁操作造成误删）利用 UUID+线程标识 标定当前线程 需要删除锁时进行判断
当 a 要删除锁时到期了，致使线程阻塞，可以使用 lua 脚本保证删除操作的原子性

**问题**
Sentnx 不可重入 不能重复调用
redis 分布式锁无法自动续期
解决：
使用 Redisson 实现分布式锁 可以不断的重入
但是 Redissson 默认释放时间是 30s，如果 30S 加锁业务没有完成，那么在 30-10S 时间进行一次时间延长。一直到锁释放完成
![asset_img](八股-项目/2023-08-28-20-24-10.png)
watchDog 是一个当前线程启动的后台线程，每隔十秒会检查一次，当前客户端在默认时间内一直持有锁就需要进行延长，
Redisss 实现可重入锁，
利用底层中的 voaltile 的 state 变量记录重入状态，每一次加锁都会进行记录+1，每释放一次 state-1 直到 state==0，释放锁
![asset_img](八股-项目/2023-08-28-20-30-26.png)

### Redis 锁宕机锁死问题

这里可能出现的死锁情况是，分布式锁未表明超时时间从而导致死锁

在 Redis 宕机的情况下，分布式锁可能会发生死锁的情况，这主要取决于锁的实现方式和程序中对于异常情况的处理。

在使用 Redis 实现的分布式锁中，通常是通过设置一个带有过期时间的键（锁）来实现的。当一个客户端获取到锁时，会设置该键的过期时间，确保即使客户端在某些情况下异常退出，锁最终会自动释放。然而，当 Redis 宕机时，锁的过期时间无法被正常更新，可能导致锁一直存在而不会被释放，这就是一种死锁情况。

为了避免在 Redis 宕机时出现死锁，可以考虑以下策略：

设置适当的锁超时时间： 设置锁的过期时间不要太长，以确保即使 Redis 宕机，锁也能够在相对短的时间内自动释放。

实现锁续约机制： 在锁即将过期时，通过续约操作来更新锁的过期时间。这需要在程序中定期执行锁的续约操作，确保锁在持有期间内一直有效。

使用可靠的锁实现： 选择使用经过验证、在 Redis 宕机等异常情况下表现可靠的分布式锁实现。例如，Redisson 等工具库提供了对分布式锁的支持，能够处理宕机等异常情况。

总体来说，确保分布式锁的可靠性需要综合考虑锁的过期时间、续约机制以及对 Redis 宕机等异常情况的处理。

### 接口限流

当我们去秒杀一些商品时，此时可能会因为访问量太大而导致系统崩溃，此时要使用限流来进行限制访问量，当达到限流阀值，后续请求会被降级；降级后的处理方案可以是：返回排队页面（高峰期访问太频繁，等一会重试）、错误页等。

实现：项目使用 RateLimiter 来实现限流，RateLimiter 是 guava 提供的基于令牌桶算法的限流实现类，通过调整生成 token 的速率来限制用户频繁访问秒杀页面，从而达到防止超大流量冲垮系统。（令牌桶算法的原理是系统会以一个恒定的速度往桶里放入令牌，而如果请求需要被处理，则需要先从桶里获取一个令牌，当桶里没有令牌可取时，则拒绝服务）

---

## 缓存问题

### 数据一致性

- 分为更新缓存

  - 更新数据库后再更新缓存（缓存更新不同步，使得缓存存在脏数据）
    线程 A 将数据库中 1->2 线程 B 将 2->3 当线程 A 更新数据库后，此时线程 B 继续尝试更新，但 B 线程更新速度较快使得 A 线程未结束时缓存已经更新为 3,此时 A 线程尝试更新缓存错误的将 3 变更为 2；造成缓存数据不一致
  - 先更新缓存再更新数据库
    线程 A 先将缓存改变为 2，此时线程 B 会再线程 A 走到数据库之前进行更新，将缓存改为 3，数据库改为 3，此时线程 A 来到数据库中修改数据为 2,即最终缓存为 2，数据库为 3，数据不一致；

> 为什么不直接使用分布式锁保证数据一致性
> 无论先更新数据库还是先更新缓存，都存在数据错乱的问题。可以加上分布式锁来解决，写数据之前都先拿到锁。但是这样会使得缓存利用率下降。同时也降低了性能。·

- 删除缓存

  - 先删除缓存再更新数据库，再查询的时候去更新缓存（读线程在写线程未修改完毕就去读 会读到脏数据）
    线程 A 先删除缓存，后去到数据库中还未更新完成，此时线程 B 发现读不存在会去读取当前的旧数据，当 A 线程更新数据库完毕后,缓存和数据库已经不一致；
  - 先删除缓存再更新数据库，延迟一段时间后再删除缓存
    称之为`延迟双删`，在读线程写入到缓存中之后，在删除一次缓存（让写线程删除读线程的脏数据），但有时候第二次删除可能在读线程写入缓存的前面，相当于删除的是空缓存，致使二次删除无效，因此，二次删除需要延迟进行并确保在读请求写入缓存之后进行。
  - 先更新数据库，再删除缓存，在查询的时候去更新缓存
    此时在更新数据和查询数据的间隙中可能会出现短暂缓存不一致问题。这里当写线程更新后还没删除缓存，读线程读取数据会是脏数据
    > 出现问题的地方：当缓存过期时候，同时读请求回写缓存在更新数据库线程操作之前进行，使得写线程删除无效，而读线程写入脏数据
    > 当缓存过期，读线程去读取缓存发现不存在，此时写线程更新数据库，之后要删除缓存，最后读线程再更新缓存即更新的是旧值。
    > 这里需要满足的情况为，缓存刚好失效，有读写并发，同时写线程写过程和删除缓存的过程， 要短于读线程读缓存和写缓存的时间。
    > 因为写数据库一般会先「加锁」，所以写数据库，通常是要比读数据库的时间更长的。

应该：写操作执行时先操作数据库在删除缓存 ，当查询时缓存为空需要从数据库中读取并更新缓存。
先写缓存再写数据库 后写的数据会产生脏数据

**修改内容时间：** 2023 年 12 月 30 日

### 缓存穿透的解决方案有哪些？

缓存穿透是指 恶意请求不存在的数据，从而查询的数据即不在 redis 中也不在数据库中，大量的请求会直接打到数据库中
解决的方法：

- 缓存 null 值
- 布隆过滤
- 增强 id 的复杂度，避免被猜测 id 规律
- 做好数据的基础格式校验
- 加强用户权限校验
- 做好热点参数的限流

### 缓存击穿问题

热点 key 失效问题，高并发访问的 key 失效，大量的访问请求达到了数据库
方法：

1. 缓存预热：在项目中先将商品信息在项目启动时便加载到 redis 中；
   实现方式：
   秒杀 controller 中实现 InitializingBean 方法会在 Bean 初始化后将商品对应的库存缓存到 redis 中。Springboot 的 Bean 的默认作用域是单例的，因此会在项目启动时加载初始化 Bean
2. 互斥锁 使用 Redission 互斥锁，每个线程的请求均需要拿到锁，这样保存线程一次只有一个线程来请求数据，不会出现大量请求失效的问题。但是使用互斥锁的项目性能不能保证，会降低系统的吞吐量。
3. 逻辑过期
4. 热点 key 永不过期 实际上热点数据是商品的信息，当商品过期也就意味着缓存中的数据没有意义，因此设置热点 key 过期时间和秒杀过期时间一致
5. 在缓存上实现接口限流
   在秒杀接口等重要接口上做好限流策略，同时使用缓存预减库存即使判断数据库存，快速失败。

### 缓存雪崩问题及解决思路

缓存雪崩是指在同一时段大量的缓存 key 同时失效或者 Redis 服务宕机，导致大量请求到达数据库，带来巨大压力。

解决方案：

- 每次秒杀请求的路径进行随机初始化，方式用户恶意刷单
- 给不同的 Key 的 TTL 添加随机值，
- 利用 Redis 集群提高服务的可用性
- 给缓存业务添加降级限流策略
- 给业务添加多级缓存

### 唯一 ID 一人一单

在分布式情况下使用 setnx 操作对下单进行加锁，并在
使用 redis 的 setnx(只有在键不存在时才会执行存储操作)，同时增加过期时间防止死锁，当线程进行操作是判断是否有其他线程获取锁，没有则执行，否则等待

- 问题
  存在分布式锁误删问题，当 a 线程阻塞并是的分布式锁超时删除，B 线程拿到锁后 a 线程会将锁进行误删，此时需要在线程中加入线程标识，每次删除锁需要对线程进行判断防止误删。最后使用 Lua 脚本对加锁和解锁做原子操作

### 登录使用 JWT

**JWT**:
以 json 为载体将信息进行安全封装并传递

- 作用：JWT 最常见的场景就是授权认证，一旦用户登录，后续每个请求都将包含 JWT,系统在每次处理用户请求的之前，都要先进行 JWT 安全校验，通过之后再进行处理。
  组成：`"token": 
"Bearer eyJhbGciOiJIUzUxMiJ9.eyJzdWIiOiJ1c2VyIiwiaWF0IjoxNjkyNjkwNTY2LCJleHAiOjE2OTI2OTIzNjZ9.jL468EdvkxQHuCo3V2ydkTWeR8dbfoP1rAvIVlHXQPUCIqP-dQ2HSqPRPv9PXszhRE4ku7B3A7vxiI4llZyJCw",`由.分割为三部分当用户下次在进行登陆是携带 token 并后台解析进行判断。
  生成的 token 直接存放在前端
  优势：自然是服务端不需要维护一个登陆表了，节省空间，特别是用户多的情况
  无状态
  缺点：
  因为是无状态的不能够随时注销，这样点 session 可以
  ![asset_img](八股-项目/2023-08-21-18-08-42.png)
  登陆：
  自定义登陆接口 认证通过生成 JWT 将用户信息存入 Redis
  自定义 user DetailService 中实现数据库
  校验：
  定义 JWT 认证过滤器
  获取 token
  将 token 存入到客户端中的，需要客户端保存好就行，无论什么保持方式，甚至你让用户写纸条揣兜里都可以！

### 项目中的 AOP 思想的体现

使用过滤器和拦截器以及 log 日志记录

**秒杀中出现的问题**![asset_img](java面试准备/2023-08-18-16-51-58.png)

执行秒杀事务的时候，先生成订单详情，然后生成秒杀订单，为了进一步确保秒杀过程中一个用户只能秒杀一件商品，可以给秒杀订单表 miaosha_order 添加一个唯一索引，如果再次插入相同的 user_id 与 goods_id，那么将不会被允许，从而在事务中插入失败而回滚：

#### 秒杀的 ABA 问题

### 接口设计

- 参数校验
  GET 请求参数会在 URL 中 使用 requestParam/PathVariable 传递参数
  POST、PUT 向服务器提交数据 参数在请求体中使用 requestBody 传递参数

### 流量削峰

- 消息队列
- 用户答题 填写验证码 延缓请求，起到对请求流量进行削峰的作用，从而让系统能够更好地支持瞬时的流量高峰
- ***

### 接口地址隐藏 防止根据秒杀的链接提前秒杀

只有秒杀时候再将秒杀的 url 地址通过 UUID 拼接数字，随机生成地址并缓存在 redis 中并发给前端，前端请求过来后验证秒杀的路径，通过再执行秒杀。

### 超时订单取消

延迟队列实现 组件 xxl-job

### 如何防止重复下单

如何判断重复订单：
用户在秒杀页面对同一个秒杀按钮多次点击

1. 使用自定义接口注解，规定在 5 秒内只能访问秒杀接口 5 次
2. 每次的订单请求都会先查询数据库，订单有唯一索引（用户 id+商品 id）,当重复订单落库时数据库会报错
3. 使用分布式锁只有获取到锁的线程才能够下单，未获取到锁则为重复下单
   之后在判断是否

不断查询数据库 性能比较低
需要放在 redis 中使用 set<good_id,userID> 集合保存已经下过商品订单的 userID，当再次下同一个商品时去判断该用户是否存在

### 如何保证下单功能和减库存事务的一致性：库存扣减成功但是订单生成失败

使用 Spring 事务@Transactional 更新库存成功后在生成订单 或者使用 lua 脚本.将减库存与生成订单操作组合为一个事务。要么一起成功，要么一起失败。

### 追问：Spring 事务 如何失效何时失效

@Transactional 开启事务，如果执行异常则进行回滚

1. 方法不是 public ，申明式事务基于 AOP 通过代理模式实现，只有 public 方法才能被访问和调用。使用了 final 修饰
2. 方法内部调用没有使用代理对象
3. 类未被 spring 管理
4. 异常被捕获并处理 事务检测不到异常 无法判断是否回滚

### 为什么使用雪花算法

![asset_img](八股-项目/2023-08-30-13-52-10.png)
高并发分布式环境下生成不重复 id，每秒可生成百万个不重复 id。 基于时间戳，以及同一时间戳下序列号自增，基本保证 id 有序递增。 不依赖第三方库或者中间件

---

### 替换 ThreadLocal

ThreadLocal 在多线程存在大量数据访问时可能会造成内存溢出

- MQ 如何包装重复消费问题：

## RabbitMQ

### 为什么选择 RabbitMQ

相对成熟，社区活跃，吞吐量高，使用 ErLang 开发，性能比较好同时有完善的可视化界面

### 消息队列的优缺点

- 异步处理 - 相比于传统的串行、并行方式，提高了系统吞吐量，和系统响应速度
- 应用解耦 - 系统间通过消息通信，不用关心其他系统的处理
- 流量削锋 - 可以通过消息队列长度控制请求量；将短时间内的大量请求分成一个时间段来处理，从而提供了请求的缓冲，提高了系统的并发量。
  缺点：
  提高了系统的复杂度和维护成本，需要考虑消息丢失，重复消费，消息顺序性和一致性的问题系统的复杂度增大

### 如何解决消息的顺序问题

### 高并发情况下接口幂等的解决方案

幂等是指: 多次调用方法或者接口不会改变业务状态，可以保证重复调用的结果和单次调用的结果一致。
对数据库操作过程中的读取和删除都是天然幂等的，需要注意的是创建和更新操作

- 对数据库使用行锁
- redis 使用分布式锁

### 如何消息不丢失

主要通过持久化机制，确保消息不丢，RabbitMQ 持久化机制分为队列持久化、消息持久化、交换器持久化。

- RabbitMQ 默认不会持久化到硬盘
  要想做到消息持久化，必须满足以下三个条件：
  Exchange 设置持久化
  Queue 设置持久化
  Message 持久化发送：发送消息设置发送模式 deliveryMode=2，代表持久化消息

- 消息 ACK 机制
  使用手动 ACK 机制，处理完成手动调用 MQ 的 ACK 方法通知 MQ 删除消息。

### 什么是延迟队列

RabbitMQ 延迟队列就是存储延迟消息的队列，延迟消息指的就是消息投递到队列后，消费者不能立刻消费，需要等待一段时间，消费者才能消费消息。重点是定时任务
RabbitMQ 原生不支持延迟消息，目前主要通过死信交换机 + 消息 TTL 方案或者使用插件完成

### 死信队列

当消息在一个队列中变成死信 (dead message) 之后，它能被重新被发送到另一个交换机中，这个交换机就是 DLX，绑定 DLX 的队列就称之为死信队列。
导致死信的原因：

消息被拒（Basic.Reject /Basic.Nack) 且 requeue = false。
消息 TTL 过期。
队列满了，无法再添加。

## 分库分表

- 分库，分表，分库分表
  这三个事儿分别是"只分库不分表"、"只分表不分库"、以及"既分库又分表"。

`分库是将原本的单库拆分为多个库，分表是将原来的单表拆分为多个表。`
将一个大型的数据库拆分成多个小型数据库，每个小型数据库称为一个分片

- 分库
  垂直分库：按照业务拆分的方式称为垂直分片，又称为纵向拆分，它的核心理念是专库专用
  水平分片：通过某个字段根据某种规则将数据分散的到多个库中去，每个分片只包含数据的一部分。其中满足规则的字段为分片键
- 分表：
  垂直分片：将表更具业务分到不同的表中。
  水平分片：将表的字段分到不同的表中

- 应用场景：

  - 分表的场景：数据量过大或者数据库表对应的磁盘文件过大。
  - 分库的场景：当数据库的连接不够客户端使用时，可以考虑分库或读写分离。
  - 分库分表的场景： 高并发写入场景，数据量巨大场景

- 路由表

## 责任链模式

对象的请求会沿着链式方向进行传递，每个处理对象都会检查能否对请求进行处理，能则处理不能继续进行传递，发送请求的对象不知道谁会处理请求，帮助请求者和处理者之间的解耦。

## 布隆过滤器

特点是高效地插入和查询，可以用来告诉你 “某样东西一定不存在或者可能存在”。
但布隆过滤器不能删除

- 原理：
  布隆过滤器通过多个哈希函数对一个数据信息生成多个哈希值将每个 hash 值指向的 bit 位置置 1，将信息映射到 bit 数组中去。
  那么可以想象到若需要映射的数量小，对应到的 bit 数组中的位置分散且不冲突，当映射对象多时，会出现部分 bit 位被多个映射对象覆盖，当需要进行查询的时候，若对象散列的值再过滤器中查到则可能存在（因为会的 bit 位会是对应其他对象的），若不能完全对应到则一定不存在。判断存在会误判，但是判断不存在不会误判
- 一般意义上的布隆过滤器不支持删除。

同样的他存储的数据量和准确性都依赖于布隆过滤器的长度，长度小越容易误判。长度太长也会使得效率降低

> TPS（Transactions Per Second）是一个衡量系统性能的指标，用于表示系统在单位时间内能够处理的事务数量。
> QPS（Queries Per Second）是一个衡量系统负载或性能的指标，用于表示系统在单位时间内处理的查询请求数量。

### 双重校验所提高缓存击穿的性能

当缓存中没有数据的时候，先获取分布式锁，只有一个线程可以成功，在查询数据库之前先用双重校验锁判断一下 ，此时缓存中是否依旧没有数据，确认后再去查数据库，并写入缓存这样其他线程拿到锁尝试去查数据库时回头看到了缓存数据可以提高效率。

# 八股

## Java Se

### 重载（overload）和重写（override）的区别

重载：如果多个⽅法(⽐如 StringBuilder 的构造⽅法)有相同的名字、不同的参数， 便产⽣了重载，是同一个类中而言
重写就是当⼦类继承⾃⽗类的相同⽅法，输⼊数据⼀样，但要做出有别于⽗类的响应时，你就要覆盖⽗类⽅法，再不同类而言

### this 关键字

this 是自身的一个对象，代表对象本身，可以理解为：指向对象本身的一个指针。

### 抽象类和接口

接口方法默认 public，不能有自己的默认实现（8 之后 default 修饰可以有自己的默认实现），抽象类可以有自己的默认实现，非抽象方法。
接口的变量只能是 static final 类型。
接口可以多实现，类只能单继承

# JVM

## 垃圾回收算法

标记：可达性分析后标记为不可达的对象

- 标记清除
  将存活的对象进行标记，然后清理掉未被标记的对象
  不足:
  标记和清除过程效率都不高；
  会产生大量不连续的内存碎片，导致无法给大对象分配内存。
- 标记-复制算法
  将可用内存按容量划分为两块，每次只使用其中的一块。当这一块的内存用完了，就将还存活着的对象复制到另外一块上面，然后再把已使用过的内存空间一次清理掉。
  缺点： 浪费空间，只能用一部分
  新生代的垃圾收集主要采用标记复制算法，默认 Eden 和 Survivor 的大小比例是 8∶1。
- 标记整理
  让所有存活的对象都向一端移动，然后直接清理掉端边界以外的内存
- 分代收集算法
  根据对象存活周期将内存划分为几块，不同块采用适当的收集算法。
  一般将堆分为新生代和老年代。
  新生代使用: 标记-复制算法
  老年代使用: 标记 - 清除 或者 标记 - 整理 算法

# MySQL 基础架构

![asset_img](面试整理/2024-01-18-20-13-31.png)

1. 最上层的客户端所包含的服务并不是 MySQL 独有的，大多数基于网络的客户端/服务器工具或服务器都有类似的服务，包括连接处理、身份验证、确保安全性等。
2. 第二层包含了大多数 MySQL 的核心功能，包括查询解析、分析、优化、以及所有的内置函数（例如，日期、时间、数学和加密函数），所有跨存储引擎的功能也都在这一层实现：存储过程、触发器、视图等。

   > 在旧版本中，MySQL 可以使用内部查询缓存（query cache）来查看是否可以直接提供结果。但是，随着并发性的增加，查询缓存成为一个让人诟病的瓶颈。从 MySQL 5.7.20 版本开始，查询缓存已经被官方标注为被弃用的特性，并在 8.0 版本中被完全移除。

3. 第三层是存储引擎层。存储引擎负责 MySQL 中数据的存储和提取。存储引擎层还包含几十个底层函数，用于执行诸如“开始一个事务”或者“根据主键提取一行记录”等操作。但存储引擎不会去解析 SQL，不同存储引擎之间也不会相互通信，而只是简单地响应服务器的请求。

## 事务

事务就是一组 SQL 语句，作为一个工作单元以原子方式进行处理，事务中的那些语句要么全部执行要么全部失败。事务遵循 ACID 特性 原子性 一致性 隔离性 持久性

> 事务的实现：事务隔离性由锁来实现。原子性、一致性、持久性通过数据库的 redolog 和 undo log 来完成。redo log 称为重做日志，用来保证事务的原子性和持久性。
> 原子性：undo log 记录了事务发生之前的数据，如果事务失败，InnoDB 会根据 undo log 回滚数据。
> 一致性由其他特性保证
> 隔离性：使用多种隔离级别进行隔离，并用 mvcc 控制不同事务版本，MVCC 通过提供数据版本来支持事务的隔离性。不同的事务会看到不同版本的数据行，这取决于事务的开始时间和它的隔离级别。
> 持久性:InnoDB 使用“redo log”来记录数据的更改，在系统崩溃后，redo log 可用于恢复数据。

- 日志  
  重做日志用来实现事务的持久性，即事务 ACID 中的 D。
  其由两部分组成：
  一是内存中的重做日志缓冲（redo log buffer），其是易失的；
  二是重做日志文件（redo log file），其是持久的。

## 多版本并发控制 MVCC 隔离级别

- 隔离级别：
  ![asset_img](面试整理/2024-01-18-20-15-54.png)
- READ UNCOMMITTED（读未提交）
  在事务中可以查看其他事务中还没有提交的修改
  `读取未提交的数据，也称为脏读`
- READ COMMITTED（读已提交）
  B 事务只能看到 A 事务提交之后的数据和修改。这个级别会产生`不可重复读问题`，因为 B 事务在 A 事务修改前后读取的数据可能会不一致，这意味着同一事务中两次执行相同语句，可能会看到不同的数据结果
- REPEATABLE READ（可重复读）
  MYSQL 默认隔离级别，保证了在同一个事务中多次读取相同行数据的结果是一样的，解决了不可重复读问题。但不能解决 `幻读`：当 A 事务在读取某个范围内的记录时，另外一个事务 B 又在该范围内插入了新的记录，当 A 事务再次读取该范围的记录时，会产生幻行。
- SERIALIZABLE（可串行化）读写都加锁全部串行执行

> 幻读：可重复读隔离级别下，是存在幻读的问题：
> Innodb 引擎为了解决「可重复读」隔离级别下的幻读问题，就引出了 next-key 锁，它是`记录锁`和`间隙锁`的组合。
> `Record Lock`，记录锁，锁的是记录本身；
> `Gap Lock`，间隙锁，锁的就是两个值之间的空隙，以防止其他事务在这个空隙间插入新的数据，从而避免幻读现象。

- MVCC
  具体而言，MVCC 就是为了实现读-写冲突不加锁，而这个读指的就是快照读(不加锁的读), 而非当前读（for upadte 这类的加锁读操作），当前读实际上是一种加锁的操作，是悲观锁的实现;
  innodb MVCC 主要是为 Repeatable-Read 事务隔离级别做的。在此隔离级别下，A、B 客户端所示的数据相互隔离，互相更新不可见
  MVCC 是行锁的变种，他在很多时候避免了加锁操作，大多时候可以实现非阻塞的读操作，写操作也只锁定特定的行因此细腻度更好，开销更低。
  MVCC 的实现是通过保存数据的某个时间点的快照来实现的，因此不管执行多长时间，每个事务看到的数据都是一致的。根据事务开始的时间不同，每个事务对同一张表，且同一时刻看到的数据是不一样的。

InnoDB 中的 MVCC 设计： 在每条记录后面保存两个隐藏的列来实现，保存了行的创建时间和行的过期时间。（实际存储时候将系统版本号替代时间）每开始一个事务系统版本号会自动递增。以及根据 undolog 记录的事务每次操作的版本链，版本链的头节点就是当前记录最新的值

SELECT
确定行创建时间： InnnoDB 查找版本早于当前的事务版本的数据行，以确保当前事务读取的数据不晚于当前事务开始时间，
确定行删除时间：要么行删除版本未定义要么大于当前事务开始时间，确保事务读取的行在事务开始之前存在

> 确定了行创建时间和删除时间均符合要求才能够进行返回结果；

INSERT
新插入的每一行保存当前系统版本号作为行版本号
DELETE
删除的每一行保存当前的系统版本号作为行删除版本号
UPDATE
插入一行新的记录，保存当前系统版本号作为行版本号，同时保存当前系统版本号到原来的行作为删除标识。

https://pdai.tech/md/db/sql-mysql/sql-mysql-mvcc.html

## 索引

### 说一下索引实现

MySQL 的默认存储引擎是 InnodB,innodb 默认的索引结构为 B+树，B+树只有叶子节点才存储数据，非叶子节点存储键值，指向了索引的方向。叶子节点的结构为`双向有序的数据链表`，因此他可以进行范围查找。同时 B+树一个节点可以存储多个孩子，使得 B+树显得更加矮胖，从而 B+树可以减少磁盘的查询次数并且不同于普通的二叉树，只需要遍历一次就可以得到所有的叶子数据，从而提高查找效率。

### 为什么使用 B+树

B+树：只有叶子节点才会存储数据，非叶子节点只存储键值，指向索引方向。叶子节点之间使用双向指针连接，最底层的叶子节点形成了一个双向有序链表,可以进行范围查找，同时为了维护底层叶子的有序性，在插入和删除时候需要对索引进行维护涉及到页面分裂和页面合并等操作。
![asset_img](面试整理/2024-01-18-20-20-25.png)

> 为什么不用普通二叉树？

普通二叉树存在退化的情况，如果它退化成链表，相当于全表扫描。平衡二叉树相比于二叉查找树来说，查找效率更稳定，总体的查找速度也更快。

> 为什么不用平衡二叉树呢？

平衡二叉树每个节点只存储一个键值和数据的，B+树可以存储多个，同时树的高度也会更低那么对应的查找磁盘的次数也会少，

> 为什么用 B+ 树而不用 B 树呢

B+Tree 的磁盘读写能力相对于 B Tree 来说更强，IO 次数更少，B+Tree 永远是在叶子节点拿到数据，不需要遍历整个树就能拿到所有数据，所以 IO 次数是稳定的，叶子节点按照顺序排序，B+树的排序能力更强

### Innodb 索引

索引，在 MySQL 中也叫作键（key）
优点：
● 索引大大减少了服务器需要扫描的数据量。
● 索引可以帮助服务器避免排序和临时表。
● 索引可以将随机 I/O 变为顺序 I/O。

- 分类
  B-Tree；B-tree 通常意味着所有的值都是按顺序存储的，并且每一个叶子页到根的距离相同。B-tree 是按照索引列中的数据大小顺序存储的，所以很适合按照范围来查询

索引类型分为`主键索引`（`聚簇索引`）和`非主键索引`（`二级索引`）。

> 非叶子节点包含了索引列和一个指向下级节点的指针

- 聚簇索引：聚簇索引的叶子节点存的是整行数据。术语“聚簇”表示数据行和相邻的键值紧凑地存储在一起。因为无法同时把数据行存放在两个不同的地方，所以一个表只能有一个聚簇索引（不过，覆盖索引可以模拟多个聚簇索引的情况）。InnoDB 根据主键聚簇数据，如果你没有定义主键，InnoDB 会选择一个唯一的非空索引代替。如果没有这样的索引，InnoDB 会隐式定义一个主键来作为聚簇索引。
- 二级索引：非主键索引的叶子节点内容是主键的值。这意味着通过二级索引查找行，存储引擎需要找到二级索引的叶子节点，以获得对应的主键值，然后根据这个值去聚簇索引中查找对应的行。这里做了双倍工作：两次 B-tree 查找而不是一次。使用主键值作为指针会
  让二级索引占用更多的空间，换来的好处是，InnoDB 在移动行时无须更新二级索引中的
  这个“指针”。

索引的主键不要使用 UUID 这样随机的主键值，它使得插入变得完全随机，且数据本身没有聚簇特性 。写入的数据不能按照顺序进行插入，需要耗费大量时间寻找合适的位置，且可能导致频繁的页分裂

> 使用 InnoDB 时应该尽可能地按主键顺序插入数据，并且尽可能地按照单调增加的聚簇键的值顺序插入新记录。

### 覆盖索引

> 覆盖索引不等同于二级索引

如果一个索引包含（或者说覆盖）所有需要查询的字段的值，我们就称之为覆盖索引，即不需要进行回表操作。在一个覆盖索引中，如果索引是针对 (age, id, username) 创建的，那么叶子节点存储了按照 age 排序的索引列值，并且还包含了每个索引行对应的 id 和 username 列的值。当执行覆盖查询时，数据库引擎可以直接从这些叶子节点中获取所有需要的列值，从而避免了额外的数据页访问，提高了查询效率。

> EXPLAIN 的 Extra 列可以看到“Using index”的信息，表示使用了覆盖索引

### 索引分类

根据叶子的内容索引分为主键索引和非主键索引（只在叶子节点存放主键信息）

> 如果我执行 `select * from T where k between 3 and 5`，需要执行几次树的搜索操作，会扫描多少行？其中 k 是非聚簇索引

- 查询过程
  现在非聚簇索引中查找 3 得到对应的主键，到聚簇索引中找到主键对应的行数据（第一次回表）
  现在非聚簇索引中查找 5 得到对应的主键，到聚簇索引中找到主键对应的行数据（第二次回表）
  在 k 索引树取下一个值 k=6，不满足条件，循环结束(第三次查询)。
  > 可以看到，这个查询过程读了 k 索引树的 3 条记录，回表了两次。在这个例子中，由于查询结果所需要的数据只在主键索引上有，所以不得不回表。

### 索引创建的注意

- 索引建立在查询频繁的字段上
- 维护索引需要成本，索引的数量应该合适
- 选择区分度高的字段作为索引
- 组合索引时将区分度高的放在前面
- 需要频繁更新的字段不适合作为索引
- 不建议用无序的值(例如身份证、UUID )作为索引

> .优化器怎么去看索引的区分度
> 一条语句可能命中多个索引，而优化器会选择合适的索引以最小的代价执行命令，我们使用 show index from table 可以查看索引的基数，即 Cardinality 字段的数字，基数越大反应了索引的区分度越大

### 索引优化

- sql 语句修改为`select ID from T where k between 3 and 5`，这时只需要查 ID 的值，而 ID 的值已经在 k 索引树上了，因此可以直接提供查询结果，不需要回表。也就是说，在这个查询里面，索引 k 已经“覆盖了”我们的查询需求，我们称为`覆盖索引`，避免了回表。
- 由于`覆盖索引`可以减少树的搜索次数，显著提升查询性能，所以使用覆盖索引是一个常用的性能优化手段。
  > `索引下推优化`能减少回表查询次数，提高查询效率。
  > 索引下推的下推其实就是指将部分上层（Server 层）负责的事情，交给了下层（引擎层）去处理。使用索引下推当被索引的列为判断条件时，先一步 过滤出符合条件的数据没，减少了回表的次数，Innodb 索引的数据和索引在一起不存在回表，也就是说只有二级索引可以使用索引下推

### 是否使用了索引 执行计划

show index from table
select 语句查看执行计划 explain 根据执行计划中的列 type 显示关联类型或访问类型
如果是 ALL 则是全表扫描，Key 列中会显示实际使用的索引。查看 Extra 列 == Using index：表示 MySQL 将使用覆盖索引，避免了回表

### 索引失效的情况

- 查询条件中包含了 or
- 包含了 like 通配符，当使用了 where name like "xxx%",依旧会匹配首字母并利用查找找到何时的数据因此，索引不会失效，同时使用的左模糊匹配（"%xx"）不一定执行全表扫描，若查询的数据在二级索引中，则只会遍历二级索引树不会回表。（覆盖索引）
- 索引列中使用了 mysql 内置函数，对索引列进行了运算
- 索引字段上使用了！= <>
- 未正确使用联合索引，使用了非最左匹配
- 列类型不匹配
- 表很小 mysql 认为查询全表的效率更高时

### 多个单列索引

在一张表中建立多个单列索引 A、B,查询条件 A=1and B=2 时索引的优化器会选择如何使用索引最高效，因此虽然两个索引都可以用但是若只选择一个索引查询效率更加高效也只选择一个索引，若是在 mysql5.7 版本后并且 INnnoDB 索引中使用 OR 会将两个索引都用上

> 多个单列索引在多条件查询时优化器会选择最优索引策略，可能只用一个索引，也可能将多个索引全用上！ 但多个单列索引底层会建立多个 B+索引树，比较占用空间，也会浪费一定搜索效率，故如果只有多条件联合查询时最好建联合索引！

### 联合索引失效

建立索引 create index tb on table(a,b,c)
联合索引失效的场景 查询 a=1 c=2 b=2 这样的查询顺序会失效吗
不会失效，查询优化器会自动优化
原因：
`alter table `test` add index search(a,b,c,d)`建立联合索引 a b c d
联合索引遵循最左匹配原则，mysql 会一直向右匹配直到遇到范围查询(>、<、between、like)就停止匹配，当 a>2 时即使 a 为最左匹配同样不能使用索引，当查询 b=2 c=2 时候未使用最左匹配 不能使用索引。其中使用=和 in 时 abcd 的索引无论为顺序还是乱序，查询优化器会自动优化可识别的形态

> 联合索引必须按照顺序使用，类似电话簿中的查询，若不知道姓，那查询起来将毫无用处，

当建立一个联合索引 (a,b,c,d) 时，查询条件 a, b, c, d 的顺序不会影响是否使用索引。
https://blog.csdn.net/qq_35275233/article/details/87888809

https://blog.csdn.net/Abysscarry/article/details/80792876

### 慢查询优化

查看慢查询 使用 MySQL 的慢查询日志定位问题语句
优化：

1. sql 语句本身：
   是否使用了不必要的列，是否指定了查询的范围，
   索引是否失效查询执行计划，是否是进行了全表扫描，查看是否正确使用了索引，索引是否可以使用到覆盖索引，使用联合索引是否成功等方面
2. 数据表是否是

### sql 性能优化

从三个方面进行回答
1、数据库设计；
2、索引设计；
3、查询优化；

- 数据库设计 尽量使用不使用 NULL 尽可能使用 NOT NULL
  使用 VARCHAR 替代 CHAR
- 索引的正确使用

### Mysql 日志

binlog 二进制日志 记录数据库所有的更改操作，主要用于数据的备份和恢复
redo log 重做日志 保存了事务的持久性 用于数据宕机后的数据恢复
undo log 回滚日志 保证了事务的原子性，用于事务的回滚和 MVCC

redo log undo log 是 mysql 中 innodb 引擎独有的
当数据库宕机后，mysql 根据 redolog 进行恢复数据库，保持数据的持久性。记录了数据提交后的数据状态

undo log 回滚日志 记录了在事务提交之前的数据状态

1. 在事务为提交之前 记录数据到 undo log 中去 当事务回滚时根据 undo log 进行回滚、
2. 实现 MVCC 通过 Read view +undo log 实现 MVCC

## 范式

第一范式：数据表中的每一列（每个字段）都不可以再拆分。例如用户表，用户地址还可以拆分成国家、省份、市，这样才是符合第一范式的。
第二范式：在第一范式的基础上，非主键列完全依赖于主键，而不能是依赖于主键的一部分。例如订单表里，存储了商品信息（商品价格、商品类型），那就需要把商品 ID 和订单 ID 作为联合主键，才满足第二范式。
第三范式：在满足第二范式的基础上，表中的非主键只依赖于主键，而不依赖于其他非主键。例如订单表，就不能存储用户信息（姓名、地址）。

## 当一个查询语句同时出现了 where、group by、having 和 order by 、join 时，执行顺序如下

查表- 选字段 - 对字段分组- 过滤-筛选-排序

- from join 先执行得到关联的表
- WHERE 子句：首先执行 WHERE 子句，提取满足条件的记录。
- GROUP BY 子句：然后按照 GROUP BY 子句中指定的列进行分组，一般结合分组聚合函数 COUNT、MAX、SUM 等在 select 中对分组进行过滤。
- HAVING 子句：分组后接着使用 HAVING 子句进行过滤保留符合条件的分组。
- SELECT 子句：接着执行 SELECT 子句，选择需要显示的列。
- ORDER BY 子句：最后根据 ORDER BY 子句中指定的列对结果进行排序。
  > having 只能用在 group by 之后
  > where 肯定在 group by 之前
  > 注意若选取的列名和关键字相同 用""包起来表示别名

## 一条 SQL 查询语句在 MySQL 中如何执行的

![asset_img](八股-Mysql/2023-08-20-17-00-51.png)

1. 查询缓存：连接器和客户端建立连接后，查询数据库缓存，如果之间执行过同样的语句则直接从内存中读取结果（执行缓存失效的情况非常频繁，MySQL8.0 后取消 ）
2. 词法分析：没有命中缓存，将解析 sql 语句为执行做准备，需要先用分析器进行词法和语法分析，判断语句是否正确。
3. 优化器优化：将正确的 sql 语句进行优化，如是否使用索引，查询表的顺序等等
4. 执行：最后通过执行器去执行语句，返回执行结果

## MySql 的存储引擎

mysql 主要分为两种存储引擎，分别是 MylSAM 和 Innodb。两者的区别在于 MyIsm 只支持表锁且索引的为非聚簇索引结构为 B 树，而 innodb 引擎支持行锁，且支持聚簇索引，innodb 索引结构为 B+树

## 如何查看执行计划

https://tobebetterjavaer.com/sidebar/sanfene/mysql.html#_26-%E6%80%8E%E4%B9%88%E7%9C%8B%E6%89%A7%E8%A1%8C%E8%AE%A1%E5%88%92-explain-%E5%A6%82%E4%BD%95%E7%90%86%E8%A7%A3%E5%85%B6%E4%B8%AD%E5%90%84%E4%B8%AA%E5%AD%97%E6%AE%B5%E7%9A%84%E5%90%AB%E4%B9%89
执行计划中的 key 列显示了使用的索引名称
Extra 中的 using index 表明了使用了覆盖索引

## 事务

## 锁

- 锁

![asset_img](面试整理/2024-01-18-20-13-50.png)

- 表级锁：开销小，加锁快；不会出现死锁；锁定粒度大，发生锁冲突的概率最
  高，并发度最低。
- 行级锁：开销大，加锁慢；会出现死锁；锁定粒度最小，发生锁冲突的概率最
  低，并发度也最高。
- 页面锁：开销和加锁时间界于表锁和行锁之间；会出现死锁；锁定粒度界于表
  锁和行锁之间，并发度一般

Innodb 默认支持行级锁，相比于 MyISAM 的表级锁而言更加细腻，对于并发事务的读写而言性能更高，行级锁的分类分为：间隙锁，临键锁，记录锁，
处理并发读/写访问的系统通常实现一个由两种锁类型组成的锁系统。这两种锁通常被称为共享锁（shared lock）和排他锁（exclusive lock），也叫读锁（read lock）和写锁（write lock）。其中资源上的读锁是共享的，或者说是相互不阻塞的。多个客户端可以同时读取同一个资源而互不干扰。写锁则是排他的，也就是说，`一个写锁既会阻塞读锁也会阻塞其他的写锁`。
锁定策略是锁开销和数据安全性之间的平衡，这种平衡会影响性能

- 表锁
  表锁（table lock）是 MySQL 中最基本也是开销最小的锁策略。它会锁定整张表。当客户端想对表进行写操作（插入、删除、更新等）时，需要先获得一个写锁，这会阻塞其他客户端对该表的所有读写操作。只有没有人执行写操作时，其他读取的客户端才能获得读锁，读锁之间不会相互阻塞。
- 行锁
  使用行级锁（row lock）可以最大程度地支持并发处理（也带来了最大的锁开销）。行锁只锁定特定行而不影响其他行的读写操作，但系统也需要花费更多的开销监控这些行级锁、锁定的时间、锁定类型以及何时清理不需要的行锁。行级锁是在存储引擎而不是服务器中实现的

### Innodb 行锁的实现

行锁是细腻度最小的锁，相比于表锁和页面锁发生冲突的可能性最低。根据查询语句的限定行锁由记录锁、间隙锁和临建锁实现例如：
当使用唯一索引进行等值查找，例如 select \* from user where id=9 时，innodb 会使用记录锁将 id=9 的数据进行加锁。而当使用 等值或者范围查询时例如 select \* from t where id > 1 and id < 6 for update 会及将 id 在 1-6 范围内的数据使用间隙锁进行加锁。select \* from t where id > 1 and id <= 6 for update 当查询数据区间在 1-6 且包含边界时，即命中了部分 记录例如（13456） 时会利用记录锁加锁同时将 1-5 之间的数据使用间隙锁进行加锁，防止其他事务在间隙中插入新行，这种结合记录锁和间隙锁的方式成为临键锁
而当使用唯一索引并匹配到了记录时，临建锁会退化为记录锁，

### MySQL 的乐观锁和悲观锁实现

乐观锁和悲观锁：
乐观锁通常通过版本号（Version）或时间戳（Timestamp）来实现
悲观锁可以通过使用 FOR UPDATE 语句来实现

### 表跟表是怎么关联的 内连接和外连接

外键

- 内连接和外连接
  内连接：返回两个表的公共部分
  全连接：在两张表进行连接查询时，返回左右表的所有行，没有就填充 null,MySQL 不支持全外连接，所以只能采取关键字 UNION 来联合左、右连接
  左外连接：在两张表进行连接查询时，会返回左表所有的行，和右表中连接字段相等的记录，右表中不符合的记录填充为 null
  右外连接：在两张表进行连接查询时，会返回右表所有的行，和左表中连接字段相等的记录 不符合搜索条件的地方均为 NULL。

### 手写个 sql 死锁，如果字段非索引会发生死锁吗

begin
update user set age= 1 where id=1;

begin
update user set age =1 where id =2;
此时两个事务均为提交获取到各自的排他锁
事务 1 执行
update user set age = 3 where id = 2;
事务 1 会一直等待释放
update user set age = 2 where id =1;
2 等待 1 释放 进入死锁

### 如何判断是否使用了索引

利用执行计划 explain 查看查询语句的执行计划 查看其中的 type 字段是否使用了索引
查看表是否有索引 使用 show index from table 的命令

---

# Redis

## 分布式锁

Redis 的性能最高
zookeeper可靠性最高
### 事务在什么时候加锁？

### Redis 的分布式锁怎么实现

### Redis 分布式锁过期怎么解决

### 看门狗机制怎么续期的，怎么知道锁的时间的呢

### 你说的是机制，底层有了解过看门狗怎么实现的吗？

## Redis 的持久化策略

RDB:RDB 持久化策略：Redis 将内存中的数据**周期性**地 dump 到磁盘上，形成快照文件。当 Redis 重启时，可以通过**加载快照文件**来恢复数据。RDB 持久化是一种紧凑的存储方式，适用于**数据集较大但更新频率较低**的场景。

> RDB 持久化 命令：SAVE（阻塞式保存） 和 BGSAVE（开辟子进程进行保存不会阻塞主进程）

AOF:通过保存 Redis 服务器所执行的写命令来记录数据库状态的
AOF 持久化策略：Redis 会将每个**写操作以追加**的形式记录在一个日志文件中。当 Redis 重启时，通过**重新执行这些写操作**来恢复数据。AOF 状态打开是，服务所执行的写命令 以 协议格式将 写命令追加到服务器中的缓存区末尾中，AOF 持久化是一种追加式写入的方式，适用于**数据集较小但更新频率较高**的场景。
![asset_img](<面试整理/![asset_img](java面试准备/2023-08-10-21-33-20.png).png>)
AOF 文件随着时间会越来越大，为了避免臃肿，AOF 重写功能，提供了新的 AOF 文件替换旧的 AOF 文件，新 AOF 文件保存了相同的数据库状态并且没有多余的命令（旧 AOF 文件记录的所有命令，但到达当前数据库状态的结果可以使用命令进行简化，例如对 list 经过四次添加变为 A B C D 并弹出了 A B 最终为 C D 那么新的 AOF 文件直接对 list 加入 C D 达到同样的状态,这样讲命令从三个减少到了一个，相当于用一条命令直接记录了当先数据库的最终状态）
同时 Redis 在 AOF 重写过程中一般使用子进程进行重写操作，子进程对数据库副本进行记录，主进程继续执行服务器命令，为了避免新的写入操作和重写后的 AOF 文件不一致问题，Redis 开辟了 AOF 重写缓存区新的执行命令会同步发送到 AOF 缓存区和重写缓存区中，

> AOF 使用写后日志 即 先将数据写到内存并执行后再写到日志中。可以**避免记录错误的执行，不会阻塞当前执行**

**两者的联系**
如果服务开启了 AOF 持久化那么服务器优先使用 AOF 文件来还原数据库状态
且只有在 AOF 在关闭状态时才会使用 RDB 持久化还原数据库。
![asset_img](面试整理/2024-01-20-16-59-55.png)

## Redis 的复制

Redis 的复制功能分为同步和传播两个步骤：
同步步骤目的在于将从服务器的状态更新至主服务器一致的状态：主服务器将 RDB 文件和缓存文件内容一起发送给从服务器用于同步
命令传播则在于当主服务的数据发送修改时，此时主从服务器的状态不一致需要将不一致的命令传播到从服务器上

## AOF 的写回策略

当 AOF 文件越来越臃肿，包含有大量的无用信息，例如已经被删除键的信息，需要及时给 AOF 文件进行刷新。即重写机制

- 每秒写回：每秒种自动更新 AOF 文件 那间隔的 1 秒钟会宕机出现数据丢失
- 同步写回 每执行一次操作即写回 性能较低
- 系统控制写回 由系统进行控制写回时机 性能较好 宕机丢失数据较多

## Redis 的部署

单机部署、主从复制部署、哨兵模式部署以及集群部署

** 高可用 复制 哨兵 集群**

## Redis 的复制

- 被复制的服务器为主服务器一般负责写，对主服务器进行复制的为从服务器一般负责读。且数据的复制是 **单向** 的两种。，只能由主节点到从节点。Redis 主从复制支持 主从同步完整重同步和部分重同步。

Redis 的复制功能分为同步和传播两个步骤：

- 同步步骤目的在于将从服务器的状态更新至主服务器一致的状态：主服务器将 RDB 文件和缓存文件内容依次发送给从服务器用于同步。其中同步复制过程分为完整重同步和部分重同步。
  - 完整重同步：主服务器将 RDB 文件和缓存文件内容依次发送给从服务器用于同步
  - 部分重同步发生在从服务器连接中断后 ，主服务将中断过程执行的写命令发送给从服务器从而保持数据的一致。
- 命令传播则在于当主服务的数据发生修改时，此时主从服务器的状态不一致需要将不一致的命令传播到从服务器上，从服务器执行后保持一致的状态。

### 哨兵

哨兵系统分为两种节点：

- 哨兵节点： 哨兵系统由一个或多个哨兵节点组成，哨兵节点是特殊的 Redis 节点，不存储数据，对数据节点进行监控。
- 数据节点： 主节点和从节点都是数据节点；

哨兵系统通过对数据节点的监控、下线、和数据转移完成自动故障转移。
![Alt text](image-1.png)
哨兵系统实现了自动化的故障转移功能，即当主服务器下线时会从从服务器中选中一个作为主服务器。
哨兵是在特殊状态下的 Redis 服务器，只不过执行的命令不同
通过哨兵监视多个主服务器和其对应的从服务器并在主服务器下线的状态下将从服务器升级为主服务器，并替代下线的从服务器处理命令 请求。

### 集群

包含一个或者多个集群节点的集群，节点之间通过握手建立连接

### redis 锁怎么实现

---

# Java 并发

> java 中的 this 当一个对象创建后，Java 虚拟机（JVM）就会给这个对象分配一个引用自身的指针，这个指针的名字就是 this。

## 线程基础

进程：进程是代码在数据集合上的一次运行活动，是系统进行资源分配和调度的基本单位。
线程：线程是进程的一个执行路径，一个进程中至少有一个线程，进程中的多个线程共享进程的资源。

### 线程状态

初始，可运行(分为拿到了 cpu 资源或者等待 cpu 时间片对应于操作系统的运行和就绪态)，阻塞（等待获取锁资源），无限等待（等待其它线程显式地唤醒，否则不会被分配 CPU 时间片），有限等待（超时自动唤醒），终止
![asset_img](面试整理/2024-01-19-14-51-50.png)

> 关于线程等待 Thread.sleep(time)常用一个`线程睡眠`进行描述
> Object.wait() 线程进入等待或者无限等待状态 常用`线程挂起`进行描述
> 睡眠和挂起描述的是行为，阻塞和等待描述的是状态
> 阻塞是被动的而等待是主动的

### 线程常用方法

- sleep( ) 和 wait( ) 的这 5 个区别
  Thread.sleep()不会释放锁资源，Object.wait()会释放锁资源
  sleep 必须传入时间，时间到自动苏醒
  wait 可以不传入时间表示一直阻塞直到 notify 进行唤醒，带时间会自动苏醒当苏醒后立即获得锁便继续执行，否则进入到等待队列中去。
  sleep() 方法没有释放锁，而 wait() 方法释放了锁
  wait() 方法被调用后，线程不会自动苏醒，需要别的线程调用同一个对象上的 notify()，sleep 会自动苏醒
- yield()
  告诉调度器，当前线程愿意放弃 cpu
- interrupt() 调用线程的 interrupt() 方法会设置线程的中断标记，中断标记的作用在于向目标线程发出 中断请求，告知该线程需要停止执行当前任务，并在合适的时机终止执行。它是一种协作机制，用于线程之间的协调和通信。调用 interrupt 不会立即中断线程，只标记当前线程为中断状态，在合适的时机进行实际中断。
  > 因此可以在循环体中使用 interrupted() 方法来判断线程是否处于中断状态，从而提前结束线程。

### 线程和进程的区别

进程：进程是代码在数据集合上的一次运行活动，是系统进行资源分配和调度的基本单位。
线程：线程是进程的一个执行路径，一个进程中至少有一个线程，多个线程共享进程资源。

### 启动线程的方式

继承 Thread 类或者实现 Runable 接口可以重写 run 方法实现线程主体
实现 Callable 接口 需要实现 call 方法实现线程主体，并且可以借助 Future 接口返回线程的执行结果和异常
使用 start（）在处理器中注册线程并执行 run 方法
若只执行 run 方法会相当于执行了 Main 函数的一个方法体 并没有启动真正意义的新的线程。

### 线程池

好处：

1. 降低资源消耗。通过重复是利用资源降低线程创建和销毁造成的消耗
2. 提高响应速度。任务到达线程池中不需要等待即可执行任务
3. 提高线程的可管理性。利用线程池对线程的分配和调优监控，做到合理的管理线程

线程池工作流程：
当提交过来一个线程后
线程池判断当前运行的线程数小于核心线程数，则启动一个新的线程处理任务
若核心线程数达到最大值后，**任务会被放入等待队列中进行排队**。
若等待队列达到最大值，此时判断线程池中的非核心线程数+核心线程数是否达到最大线程数量 若没达到则创建线程来处理等待队列中的任务。否则任务进入到拒绝策略中。
线程从等待队列中取任务执行，执行完毕后在超过非核心线程的最长等待时间会，且当前线程数超过核心线程数会被关闭。

#### 创建线程池的方式

通过 Executors 创建
通过 ThreadPoolExecutor 手动创建线程池。

- 线程池参数
  核心线程数
  最大线程数
  非核心线程数空闲时间
  时间单位
  等待队列
  线程工厂
  拒绝策略

* 等待队列
  有界队列：
  - ArrayBlockingQueue 按照先进先出排序 数组实现
  - LinkedBlockingQueue 链表实现 可设置容量 不设置容量为无限队列容量 Integer.MAX_VALUE
  - DelayQueue 延迟队列 执行定时周期任务的队列
    无界队列
  - PriorityBlockingQueue 优先级队列
* 拒绝策略
  AbortPolicy ：直接抛出异常，**默认**使用此策略
  CallerRunsPolicy：用调用者所在的线程来执行任务，哪来回哪去
  DiscardOldestPolicy：丢弃阻塞队列里最老的任务，也就是队列里靠前的任务，把最前面的挤掉
  DiscardPolicy ：当前任务直接丢弃。

### 线程池重启后的任务

此时应用重启了，那么这些任务将会丢失

### 核心线程数可以大于最大线程数吗

不可以

### 为什么阿里规范不能用 Executors 创建

`线程池不允许使用 Executors 去创建，而是通过 ThreadPoolExecutor 的方式，这样的处理方式让写的同学更加明确线程池的运行规则，规避资源耗尽的风险`

使用 Executors 创建出来的常见线程池有

- newFixedThreadPool 固定线程数的线程池，其阻塞队列是无界队列会产生 OOM
- newCachedThreadPool 没有限制线程的数量会消耗大量的资源
- Executors.newSingleThreadExecutor()方法创建的线程池只有一个工作线程，在线程异常终止后会创建新的线程替代，使得消耗大量的系统资源
- 同时 Executors 类隐藏了线程池的一些细节，例如线程池的最大容量、队列类型等，这可能导致在某些情况下无法满足特定的需求，例如需要限制线程池的大小或者使用特定类型的队列。

#### 线程池 submit 和 execute 方法的区别

submit 会返回线程执行的异步结果 future 对象 根据 future 对象可以判断是否执行成功
execute 用于提交不需要返回值的任务

#### 线程池的关闭

shutdown() 将线程池状态置为 shutdown,并不会立即停止，任务不能继续提交，直到线程池内部处理完成才结束
shutdownNow()能立即停止线程池，正在跑的和正在等待的任务都停下了

---

### Volatile 是轻量级同步机制

Volatile 是轻量级同步机制，保证可见性，禁止指令重排、不保证原子性

> 1. 指令重排序：
>    对象分配的过程：1. 分配内存空间即 new 关键字执行 2. 初始化对象即执行构造函数 3. 将对象的引用指向分配的内存空间，即通过 *.*访问对象属性和方法
>    其中 2 和 3 的顺序可以颠倒，致使未初始化的对象引用暴露出来。
> 2. 保证可见性：当变量被 Volatile 修饰后，对一个 Volatile 变量的读，总能看到任意线程对于 Volatile 变量的最后的写入。
> 3. 原子性：
>    单个的 volatile 变量的读写具有原子性，但复合操作不具有。

- 禁止指令重排： 在对这个变量进行读写操作的时候，会通过插入特定的 内存屏障 的方式来禁止指令重排序。

- 如何保证可见性
  volatile 在写操作执行之前会出发 lock 前缀指令。

  1. 将当前处理器中的数据写回到系统内存中去。利用缓存锁定，根据缓存一致性机制阻止多个处理器修改同一内存数据。
  2. 一个处理器的缓存回写到内存会导致其他处理器的缓存无效.

> 处理器数据先从内存中进入到缓存中去，并不直接操作内存 这样提高数据的处理速度。
>
> 1.  总线锁
>     当一个处理器在总线上输出此信号时，其他处理器的请求将被阻塞住，那么该
>     处理器可以独占共享内存。
> 2.  缓存锁： 阻止同时修改由两个以上处理器缓存的内存区域数据

- 不能保证原子性：对于复合操作不能保证原子性

### Volatile 的内存规则和行为

- 写：
  写入一个 volatile 变量后，会将改线程本地内存中的该变量值刷新到共享内存中去
- 读：
  读取一个 volatile 变量，会将本地内存中的该变量旧值设置为无效，并从共享内存中去读取新值。
  通过借助共享内存给桥梁，实现了两个线程之间的通信，保证了读线程能够及时看到写线程对共享变量的修改。

> 锁释放与 volatile 写有相同的内存语义；锁获取与 volatile 读有相同的内存语义
> CAS 操作同时具备 volatile 读和 volatile 写的内存语义，即 CAS 读取共享数据时的过程和 volatile 读过程相同，总是将共享变量读取到内存中去，从而读取到最新值。CAS 的修改数据也会将数据刷新到共享内存中去。

---

## synchronized

- 什么是 Synchronized：这是 Java 控制多线程访问共享资源的一种方式，是线程之间通信的一种方式。

- 什么同步代码块：同步代码块用于阻止多个线程同时对同一方法中的部分代码进行访问。
  理解起来，可以看成同步代码块相当于一个保护共享资源的一块区域，这个区域需要有特定身份的线程才能够进行访问，而这个身份便是锁。

- 什么是锁：锁是一个概念，Java 中任何对象都能够成为一把锁，且只要获得了被同步代码块认可的锁即可访问同步代码块中的共享资源。

一般而言 Synchronized 的形式为

```java
Synchronized(锁){
    //同步代码块
    //这里访问共享资源
}
```

总体而言，Synchronized 修改的地方分为方法和代码块上：
修饰代码块，我们知道锁定的便是代码块中的内容。
修饰方法，则可以分为修饰的是静态方法还是普通方法：

1. 静态方法：静态方法属于类，其锁住的便是整个 Class 对象。只要是同一个类便是同一个锁
2. 普通方法：锁住的是方法调用该方法的对象。只要是同一个类下的同一个方法实例便是同一个锁

- Synchronized 特点
  原子性，有序性，可见性，可重入性，不能禁止重排序

**实现原理**
synchronized 的锁存放于对象头中，其中的 Mark word 标记字段记录了锁的变化，Mark Word 存储对象的 HashCode 分代年龄 锁标志位。

- 加锁和解锁的过程
  通过锁监视器，同一个对象同一时间只与一个 monitor 相关联，当对象尝试获得锁时，monitorenter 会将 monitor 计数器+1，表示占有锁，其他线程在想要需要等待。
  如果该线程继续重入锁，则计数器继续+1.
  锁释放：进过 monitorexit 每次将计数器-1，一直减到 0 表示该线程释放锁。
  如果其他线程获取锁失败，会进去到同步队列进行阻塞，一直到锁被释放才能够尝试获取锁。
  ![Alt text](image-37.png)
  对象监视器，同步队列以及执行线程状态之间的关系
- 可重入锁
  统一进程再次获取相同锁的时候不会因为锁未释放而阻塞，会自动获取。

### synchronized 锁升级过程

总结而言： 偏向锁通过对比 Mark Word 解决加锁问题，避免执行 CAS 操作。而轻量级锁是通过用 CAS 操作和自旋来解决加锁问题，避免线程阻塞和唤醒而影响性能。重量级锁是将除了拥有锁的线程以外的线程都阻塞。

jdk1.6 之前的 synchronized 基于进入和退出 monitor 对象来同步代码块。这种锁称为重量级锁，为了提升获得锁和释放锁带来的性能增加了“偏向锁”和“轻量级锁”，锁随着竞争关系不断升级，同时这种锁升级却不能降级。

1. 偏向锁
   当同步代码块中只有一个线程在访问，不存在竞争的情况下，会使用偏向锁来偏向于第一个访问锁的进程，从而达到减少锁释放和获取所消耗的性能。
   偏向锁获取过程如下：

   1. 第一次访问，当前线程进入到同步代码块获得锁时，在对象头和栈帧中存储线程 ID 并设置锁标志位为偏向锁，以后带有相同线程 ID 的线程尝试获取锁时不需要进行加锁和解锁的过程。

   2. 进程访问同步代码块获取锁时，判断对象头中的标志位是否是偏向锁，且线程 ID 是否指向当前线程。若是则直接执行同步代码，否则若线程 ID 未指向当前线程，通过 CAS 竞争将 mark word 中的线程 Id 设置为当前线程之后，指向同步代码块，若竞争失败，会在全局安全点即（在这个时间点上没有字节码正在执行）上对进程进行挂起，偏向锁升级为轻量级锁。

   > 1. 偏向锁的释放，只在其他线程尝试竞争时才会释放。适用于无竞争状态
   >    竞争过程偏向锁是在无锁争用的情况下使用的，也就是同步开在当前线程没有执行完之前，没有其它线程会执行该同步块，一旦有了第二个线程的争用，偏向锁就会升级为轻量级锁，如果轻量级锁自旋到达阈值后，没有获取到锁，就会升级为重量级锁；(旋转的阈值在 1.6 之后引入了自适应阈值，并不是固定的)
   > 2. 这里的 CAS 竞争：它会尝试原子性地将对象头的锁状态从无锁（或其他状态）修改为自己的线程 ID，尝试获取锁的过程中可能会涉及多次循环尝试，直到成功获取锁。如果 CAS 竞争失败，代表当前线程无法直接获得偏向锁，因为有其他线程尝试获取同一个对象的锁

2. 当偏向锁有竞争时会升级为轻量级锁。当进程进入同步代码块中 JVM 在当前线程栈帧中创建存储锁记录的空间用于拷贝对象头的 mark word, 之后使用 CAS 将对象头中的 mark word 替换为指向锁记录的指针，若成功则获得轻量级锁，若失败则表示有竞争继续 cas 自旋操作。
   轻量级锁在释放时将锁记录中的 Mark word 替换会对象头，如果成功表示没有竞争, 失败则表示存在竞争需要进行锁膨胀为重量级锁

> 轻量级锁通过 CAS 自旋获取锁，避免了竞争过程中线程的阻塞，提高了执行效率。但自旋也会消耗 cpu。

### synchronized 和 volatile 有什么区别

synchronized 可以用在方法和代码块上，多用于实现多线程之间的同步，volatile 只能修饰变量，多用于解决变量之间的可见性。volatile 是轻量级的同步实现，能够保证数据的可见性 和 禁止指令重排序不能保证原子性 sys 可以保证原子性和可见性

---

# 并发

## JMM

### 线程之间的通信

java 线程通根据内存共享（隐形不可见）和消息传递（显示的）来实现
Java 的内存中堆是共享的。通过读写内存的公共状态进行隐式通信
在消息传递的并发模型中通过线程之间的消息传递进行通信。

### Java 内存模型

![asset_img](八股-Java并发/2023-12-31-20-22-10.png)

- JMM 是 Java 内存模型一种规范，屏蔽了各种硬件和操作系统对内存访问的差异，从而在不同平台上达到一致性的内存访问效果，同时也规定了线程和内存之间的关系，线程之间的共享变量 存储在主内存中，每个线程有自己的本地私有内存，其中存储了 主内存中的共享变量的副本，以主内存作为变量共享以及更新的桥梁从而，JMM 控制了 Java 线程之间的通信
  **内存的可见性的实现:smiley:**
- 线程通过 JMM 的通信：
  线程 A 向其他线程发送消息，需要借助共享内存去实现通信，即线程 A 先将自身本地内存中的变量刷到共享内存中去，其他线程在从共享内存中去读取线程 A 更新过的共享变量。
  所以 JMM 控制本地内存和共享变量的交互从而实现了内存的*可见性*。
- 指令的重排序
  Java 源代码到执行过程实现： 1.编译器的重排序，2. 指令的并行重排序，3. 内存系统重排序，最终执行的指令排序。这些重排序可能会导致多线程程序出现内存可见性问题。
  > 1 属于编译器重排序，2 和 3 属于处理器重排序
  > 针对禁止编译器重排序依赖于 JMM 的编译器重排序
  > 针对处理器重排序，依赖于在指令排序之前插入特定的类型的内存屏障

由于处理器对内存的读/写操作的执行顺序，不一定与内存实际发生的读/写操作顺序一致。处理器内部的写缓存对外不可见，且一般都允许进行重排序，从而造成了结果的不一致。
为了保证内存可见性，Java 编译器在**生成指令序列的适当位置**会插入内存屏障指令来禁止特定类型的处理器重排序。

> 相当于在指令位置插入红绿灯，人为的控制指令的执行前后顺序。

- happens-before 原则
  解释操作之间的内存可见性。如果一个操作执行的结果需要对另一个操作可见，那么这两个操作之间必须要存在 happens-before 关系，但并不意味着 A 操作要在 B 操作之前执行，仅仅是 A 操作的结果对 B 可见。
  而 happens-before 的实现来自于 JMM 限制编译器和处理器的重排序优化。
  > MM 可以通过 happens-before 关系向程序员提供跨线程的内存可见性保证

---

## 重排序

重排序遵循数据依赖性，不改变存在依赖的数据执行顺序
**对单线程的影响**

- as-if-serial，单线程下对存在控制依赖的操作重排序，不会改变执行结果

  > 控制依赖：如 if-else while 等判断

  **对多线程的影响**
  在多线程程序中，对存在控制依赖的操作重排序，可能会改变程序的执行结果。通过 happens-before 完成对多线程内存可见性的保证。

---

## 顺序一致性模型

在顺序一致性模型中，系统中的所有处理器都能够看到相同的、全局一致的操作序列。

- 什么是数据竞争
  多个线程未同步且同一个变量进行读写操作

- 顺序一致性模型的特点
  1. 一个线程中的所有操作必须按照程序的顺序来执行
  2. 每个操作对所有线程来说都是原子执行的，并且操作的结果对所有线程都是立刻可见的
     顺序一致性模型中，所有操作完全按程序的顺序串行执行

---

## 锁

![asset_img](面试整理/2024-01-20-19-19-02.png)

### 说说乐观锁和悲观锁

乐观锁与悲观锁是一种广义上的概念，体现了看待线程同步的不同角度
悲观锁：在对共享数据操作的过程中，认为每次对数据的使用过程中都会有其他线程试图修改数据，所以在每次的线程访问时都需要加锁，其他线程的操作只能等待。可以使用 synchronized 关键字或 Lock 类来实现悲观锁。适合于写操作较多的场景。（数据库的行锁和表锁）

乐观锁：认为线程在访问共享资源时候，不会有其他线程试图修改数据，只在数据更新时候去检查是否有其他线程修改了数据。 由无锁编程实现，适合于读多写少的场景，使用版本号或者 cas 实现

#### CAS

对比交换，是一条 cpu 原子指令，解释为：CAS 操作输入一个操作前的旧值和想要更新的新值，在操作期间若旧值没有变化，则更新，否则不更新。也因为 CAS 是原子操作，并发时不需要使用锁，也因为是无锁机制，cas 是乐观锁的一种
_CAS 三大问题_

- CAS 的 ABA 问题
  CAS 检查旧值无法判断旧值的变化次数，假如旧值 A 在检查前变为 B 又变为 A，CAS 无法知道旧值已经发生了变化。对于次，我们可以添加版本号，每次变量更新时都将版本号+1
- 循环时间长开销大
  自旋情况下回消耗 cpu 资源
- 只能保证一个共享变量的原子操作
  是对多个共享变量操作时，循环 CAS 就无法保证操作的原子性，这个时候就可以用锁

### 自旋锁 VS 适应性自旋锁

为什么需要自旋锁：锁在切换线程过程中，需要对线程进行阻塞或者唤醒，这中间需要 cpu 状态切换完成，资源消耗非常明显，而对于锁定时间很短的同步资源而言，利用系统级的阻塞和唤醒花费的时间要明显大于其锁定时间，因此在多处理器中我们让想要获取锁的线程稍微等待一下，不要进入阻塞状态而继续占有 cpu，让占有锁的线程释放锁之后去直接获取锁。
这其中的“等待一会”便是线程的自旋操作，但自旋也有时间限制，要求要小于系统对线程切换的时间，防止得不偿失，白白占用 cpu 资源，一般当自旋超过 10 次（默认）便需要考虑阻塞。

适应性自旋锁：为了更灵活的使用自旋锁，减少在占有锁的进程中在自旋进程刚刚自旋完就释放锁的情况，自适应自旋锁将根据上一次锁自旋时间和对应锁占有者释放情况控制当前锁自旋次数。若上一次成功获得过锁，会增加自旋次数，反之认为获得锁的概论小而减少自旋时间。

### ReentrantLock

可以实现公平锁（默认）和非公平锁，

内部维护了表示锁占用状态的 state 变量，当同一个线程来获取锁时，state 会+1 并
继续获得锁，依次达到锁可重入效果，同时若获取失败进入到 CLH 队列中等待，ReentrantLock 释放锁的次数和重入锁的次数相同才能够释放。

### AQS

用来构建锁和同步器的框架。AQS 是将每条请求共享资源的线程封装成一个 CLH 锁队列的一个结点(Node)来实现锁的分配。使用 volatile 修饰变量 state 表示同步状态，同时当资源被占用是，线程会使用 CLH 锁实现线程的阻塞和分配。

---

## 双重校验锁

- 版本 1
  ![Alt text](image-40.png)
  B 线程执行到 2 时候，为完成初始化，此时 A 依旧会向下走，从而创建多个初始化对象
- 版本 2
  ![Alt text](image-41.png)
  在创建对象的方法上同步锁，会使得其他线程阻塞，而消耗资源
- 旧版的双重校验锁
  ![Alt text](image-42.png)
  当找不到对象引用时候，会进行加锁。当 A 线程走到 7，其中出现了对创建对象的重排序，使得先完成对象内存空间的分配，在进行初始化对象，而 B 线程访问 4 时知道对象不为 null，会去访问 instance 但此时 instance 还未创建完成，从而访问一个未初始化的对象。因此我们需要在创建对象的时候禁止 JMM 的重排序。
- 双重校验锁

  ```java
  public class Singleton {
  private volatile static Singleton uniqueSingleton;

      private Singleton() {
      }

      public Singleton getInstance() {
          if (null == uniqueSingleton) {
              synchronized (Singleton.class) {
                  if (null == uniqueSingleton) {
                      uniqueSingleton = new Singleton();
                  }
              }
          }
          return uniqueSingleton;
      }

  }
  ```

- 静态内部类初始化
  ![Alt text](image-44.png)

---

### ConcurrentHashMap

并发环境下 hashMap 会产生环形链造成死循环。而 hashTable 的同步方法会阻塞其他线程的访问进去等待状态，效率底下。ConcurrentHashMap 是并发效率高的 hashMap 能够
证线程安全的同时又能保证高效的操作。
ConcurrentHashMap 使用了分段锁技术来提高 Hash table 中的访问问题，在写操作时通过使用分段锁技术对操作段加锁而不影响其他段的操作。
1.8 之前是使用分段锁技术，即由 Segment 和 HashEntry 实现，每个 segment 包含了 HashEntry 数组，当线程进行并发写时，只锁定具体的 segment，不涉及其他 segment。默认的 Segment 长度是 16。
put：根据插入的 key 计算 hash 确定对应的 segment，若 segment 不为空则使用 ReentrantLock 进行加锁，若锁获取失败则自旋，当拿到锁后遍历 entry 数组并若 key 相同则替换，不同则插入。
1.8 之后使用 Node 数组+链表+红黑树的方式实现并发安全。
put:计算 hash 确定对应的 node 若为空则 CAS+自旋进行初始化并写入数据，否则使用 synchronized 写入数据并判断链表长度大于 8 则树化，否插入到链表末尾。

### ConcurrentHashMap 为什么 key 和 value 不能为 null

因为 null 值由二义性，在并发条件下无法确定 null 到底是一个键或值不存在，还是真正的 null 值，不能够很好的保证并发情况下的安全。

> HashMap key 和 value 可以 null 因为 HashMap 本身不是线程安全的不需要设计到并发安全问题

### key 为什么不能为 null

Java 的集合框架通常禁止键或值为 null，以确保编程规范的一致性。null 无法散列不能确定 hash 位置

### ThreadLocal

本地线程变量，访问改变量的线程都会有一个本地拷贝，从而线程操作该变量的时候实际上是操作自己内存中拷贝，从而实现线程隔离的效果。实际上是个 map 集合
ThreadLocal 主要用来保存用户信息的上下文，这样多线程用户访问的各个请求会根据 ThreadLocal 的数据确定具体的用户

- 内存泄露的问题
  如果 ThreadLocal（ThreadLocalMap 的 Key）被垃圾回收器回收了，但是 ThreadLocalMap 生命周期和 Thread 是一样的，它这时候如果不被回收，就会出现这种情况：ThreadLocalMap 的 key 没了，value 还在，这就会造成了内存泄漏问题。
  我们需要在 ThreadLocal 用完后对其进行回收 remove

---

参考链接：https://pdai.tech/md/java/thread/java-thread-x-lock-all.html

---

# spring

## Spring Bean 的生命周期

## Spring 常见的设计模式

## 重点：Spring 如何解决循环依赖问题

首先我们需要说明，Spring 只是解决了单例模式下属性依赖的循环问题；Spring 为了解决单例的循环依赖问题，使用了三级缓存。
第一层缓存（singletonObjects）：单例对象缓存池，已经实例化并且属性赋值，这里的对象是成熟对象；
第二层缓存（earlySingletonObjects）：单例对象缓存池，已经实例化但尚未属性赋值，这里的对象是半成品对象；
第三层缓存（singletonFactories）: 单例工厂的缓存

---

# 主管面

## 你有什么优点

有沉浸学习的能力，较好的安排时间的能力，给自己制定计划，享受高效率的学习和工作。
是一个认真且全力以赴的人，不希望给以后的自己留有遗憾。
喜欢和团队一起工作，乐于沟通

## 你有什么缺点

公开演讲的能力有待提高，容易紧张，心肠软，拒绝别人，社会阅历少

## 多项目同时进行时如何管理时间

做好规划，设置项目优先级，确定小组成员的任务，定期做检查，共同帮助提供解决思路
使用

## 未来有什么发展规划

短期规划：想走技术路线，精进自己在开发方向的功力，深入了解项目所需要的业务，做好对项目的管理。找到并弥补自己在业务和技术方面的不足，同时要做到居安思危，要有努力挑战自己的决心，希望以后承接公司更多的任务，能够有能力带领团队创造更大的价值

# 反问

. 问业务
问技术栈
后续贵公司对新人的培训流程是什么样的
晋升制度内容

# 面经

## 连连支付

8-25

- 接口响应慢怎么解决

  1. 排查数据库问题，是否是存在慢查询，操作数据库的线程处于等待状态，导致变慢，此时也可能会出现 OOM 问题，是否索引失效；
  2. 网络连接是否正常，WEB 应用：可通过前端浏览器，开发者工具，network 查看前端耗时较长的接口，逐层定位
  3. 业务中是否有多层 if-else 嵌套或者循环嵌套

- 追问:explain 语句各个字段意思（如何查看执行计划）；如何查看索引失效
  在 select 语句之前添加 explain 会返回语句的执行计划。执行计划中的 key 字段显示了所使用的索引。

---

- 联合索引失效的场景 查询 a=1 c=2 b=2 这样的查询顺序会失效吗
  不会失效，查询优化器会自动优化
  原因：
  `alter table `test` add index search(a,b,c,d)`建立联合索引 a b c d
  联合索引遵循最左匹配原则，mysql 会一直向右匹配直到遇到范围查询(>、<、between、like)就停止匹配，当 a>2 时即使 a 为最左匹配同样不能使用索引，当查询 b=2 c=2 时候未使用最左匹配 不能使用索引。其中使用=和 in 时 abcd 的索引顺序和乱序，查询优化器会自动优化可识别的形态

  当建立一个联合索引 (a,b,c,d) 时，查询条件 a, b, c, d 的顺序不会影响是否使用索引。
  https://blog.csdn.net/qq_35275233/article/details/87888809

---

- 这里你做了那个秒杀的项目,这里使用 Redis 预减库存主要是为了做什么呢,就是它能解决什么问题
  你主要是就是它这个优化是到底是在优化什么呢它能解决什么问题呢
  使用 Redis 预减库存主要是为了做什么呢,就是它能解决什么问题
  主要目的减少对数据库的访问,可以拦截卖完了之后多余的请求，防止多个请求不断达到数据库造成压力，同时不需要考虑库存数据一致性
  实现思路：

1. 先将商品信息加载到 Redis 缓存中
2. 当收到秒杀请求时，在访问 Redis 之前先在内存标记中获取对应商品的库存数量，做到不需要对 Redis 进行访问就得到了库存，减少了高并发下的 Redis 压力，再判断 Redis 中的缓存商品数量预减并判断是否足够，不足则直接返回异常，并标记内存库存不足。
3. 否则请求入队并返回前端并进入秒杀队列，前端进行轮询判断是否秒杀成功。

---

- 秒杀的时候你是怎么解决超卖的问题
  - 追问:如果就是这种行解锁,其实对于你本身这个秒杀接口的性能有了限制，那有没有其他方案去实现解决这种超卖的问题
  - 追问直接使用 SetNx 会不会有问题
  - 追问：setnx 如何评估释放锁的时间
    watchDog
- 如何保证缓存数据的一致性
  （缓存延时双删的问题）先删除缓存后：
  当 a 先删除缓存后 B 去查询缓存，此时 a 还未跟新缓存，则 b 得到了缓存中的旧值，是否会更新缓存造成缓存中存在脏读信息，
- 如何保证下单功能和减库存事务的一致性：库存扣减成功但是订单生成失败
  使用 Spring 事务@Transactional 更新库存成功后在生成订单 或者使用 lua 脚本
- 追问：Spring 事务 如何失效何时失效
- 分布式还是单体应用
- 为什么用雪花算法
- JVM 的三色标记
- 为什么用 RabbitMQ
- RabbitMQ 如何解决消息重复和一致性问题
- 使用过什么设计模式
- 说一下责任链模式
- 查看 Linux 中的某一个进程
- 查看 Linux 中所有进程

## 卓望数码一面

- 自我介绍

- 实习项目介绍

- 介绍 list 集合

  - ArrayList 和 LinkedList 区别
  - 扩容机制 （这里答错了写成了 15）

- 事务的 ACID 属性

- Spring 中事务失效的场景（\*\*）

- 单例模式

  - 如何保持单例模式的线程安全

- ThreadLocal 存储原理和使用场景

  - 避免 ThreadLocal 避免 OOM

- 为什么我们不用 Executors 默认创建线程池的方法，而直接自己手动去调用 ThreadPoolExecutor 去创建线程池

- springboot 常见注解

  - springboot 的@SpringBootApplication 组合注解
  - springBoot 如何切换生产或者测试环境
  - spring 的 bootStrap.yml 和 application.aproties 文件加载顺序

- 微服务相关

  - 降级和熔断的区别

- Mysql 数据库的索引
  - mysql 的主键自增的原因
    可以聊到索引的数据结构 B+树，目的在于提高查询的范围和效率、增加排序的效率，提高扫表的能力，当一张数据页满后能够直接在新的数据页中继续写即可
    为什么自增：
  - 表连接的三种方式
  - 表锁和行锁
  - 锁升级表锁的情况

### 爱旭太阳能 深圳

- IDEA 的快捷键
  搜索： Ctrl+F
  搜索替换 Ctrl+R
  撤销 Ctrl+Z
  代码格式化 Ctrl + Alt + L
  全局查找 Ctrl + Shift + F
  全局查找替换 Ctrl + Shift + R
  注释 Ctrl+ /
  代码块注释 CTRL+ shift+/
  try catch 快捷键 ctrl + alt +t

- Linux 常用命令
  cd 目录 进入指定目录
  cd /home
  cd .. 返回上一级
  pwd 显示工作路径
  ls 展示当前目录下的文件
  mv -f/-i/-u 移动文件
  修改权限

  ```shell
  chmod u=rwx,g=rwx,o=rwx aa.txt/或者目录
  chmod o+w 文件/目录（将文件或者目录的其他用户加上写权限）
  chmod a-x 文件/目录 (将文件的全部用户的权限取消执行权限)
  ```

- 前后端分离项目
  前后端的程序员根据开发文档进行并行编写并调试，遇到问题可以同步协商解决

  > VUE 是想响应式的前端开发框架，是使用 JS 封装。

- Spring、SpringMVC 和 SpringBoot 之间的关系
  Spring 是个多模块的集合，旨在简化 Java 企业开发
  提供了很多的功能和支持包括 AOP DI,支持 RESTful Java 应用程序的开发。

- SpringCloud 是构建在 Spring Boot 之上的服务治理框架，能够使得开发者更加快递启动和开发。提供了全套的分布式系统解决方案，包含了：服务注册与发现、配置中心、服务网关、智能路由、负载均衡、断路器、监控跟踪、分布式消息队列等等。

  SpringMVC 是 Spring 中的一个重要模块，主要赋予
  MVC 架构开发 Web 应用的能力
  Spring Boot 是简化配置 Spring 开发，减少编写配置类 xml 等显示配置的过程，提供了默认的配置和约定大于配置的理念，其中集成了很多常用框架工具

- 软件开发生命周期
  1、可行性研究阶段；确定软件的开发目标及其可行性。
  2、需求分析阶段；对软件需要实现的各个功能进行详细分析
  3、设计阶段；分为两个阶段概要设计， 确定整个软件的技术蓝图，负责将需求分析的结果转化为技术层面的设计方案
  详细设计概要设计的基础上进行进一步的细化
  4、实现阶段；
  5、测试阶段；
  6、维护阶段。做好软件的维护和故障排除工作

- springcloud 组件。

- Redis 在 SpringCloud 中的作用
  充当主数据库，缓存或消息代理

- SpringMVC 的请求流程
- Vue 显示和隐藏
  v-if 以删除或添加 dom 结点控制元素的显示隐藏
  v-show 是通过添加样式 display:none 控制元素的显示隐藏

- Java 基础
- 集合源码
  - 实现一个 arraylist 怎么做
- 说一下 countdown，juc 那个计数器

- 线程安全和不安全

- 不用 juc 包的类，你怎么保证线程安全

- Java 内存模型 JMM 之一内存交互操作

- 如果让你设计一张表怎么设计

### 金蝶

- 自我介绍
  面试官您好，我是汕头大学 2024 届计算机技术专业的硕士研究生，本科就读于 安徽工程大学的软件工程专业。在本科阶段和研究生阶段我获得过多次奖学金并通过了六级考试，同时发表了一篇 sci 论文，在专业知识方面我深入了解过 Java 集合并发编程，MySQL、Redis 等相关的内容，今年的六月到九月我在亚信科技做过 Java 开发实习生的工作（实习经历），所在部门负责中国移动 APP 拉端搜索相关业务的开发，之前还做过一个关于学生购票和博客分享方面的项目。在简历投递之前我了解到咱们公司是行业领先的企业管理软件及电子商务应用解决方案供应商，拥有强大的创新能力和丰富的业务经验，对此我非常希望能够得到在这里学习和成长的机会，并继续从事 Java 开发方向的工作。那么这里的我的自我介绍完毕。

- jvm（gc、调优）
- mybatis 读取参数
  #{}防止 sql 注入，赋值时以字符串的形式加入到 sql 中 ${} 适用于列名

  1. 单个字面量类型的参数
     此时可以使用${}和#{}以任意的名称获取参数的值

2. 多个字面量类型的参数
   此时 MyBatis 会自动将这些参数放在一个 map 集合中，使用按照参数的顺序 使用 arg0 arg1 或者 param1 param2 等方式引用
3. map 集合类型的参数
   访问 map 集合的键
4. 实体类参数
   访问实体类的属性引用

   顺序传参法 #{}里面的数字代表传入参数的顺序
   @Param 注解传参法 #{}里面的名称对应的是注解@Param 括号里面修饰的名称
   Java Bean 传参法 #{}里面的名称对应的是 User 类里面的成员属性

- mybatis 加载过程，二级缓存
  一级缓存的作用域是同一个 SqlSession，在同一个 sqlSession 中两次执行相同的 sql 语句，第一次执行完毕会将数据库中查询的数据写到缓存（内存），第二次会从缓存中获取数据将不再从数据库查询，从而提高查询效率。
  二级缓存是 SqlSessionFactory 级别，通过同一个 SqlSessionFactory 创建的 SqlSession 查询的结果会被缓存；可以在多个 SqlSession 之间共享，此后若再次执行相同的查询语句，结果就会从缓存中获取
  - 数据库表怎么设计的
    选择合适的存储引擎 支持事务 行锁 好的并发性能
    主键
    必须把字段定义为 NOT NULL 并且提供默认值 做索引
    选择合适的字段类型 varchar 替换 char
    时间格式
    建立组合索引，必须把区分度高的字段放在前面
- 索引

1. 分类
   使用角度看的话分为：
   主键索引， InnoDB 主键是默认的索引，数据列不允许重复，不允许为 NULL，一个表只能有一个主键。
   唯一索引： 数据列不允许重复，允许 null 可以创建多个唯一索引
   普通索引: 基本的索引类型，没有唯一性的限制，允许为 NULL 值。
   组合索引：多列值组成一个索引，用于组合搜索，效率大于索引合并 2. 数据结构
   哈希索引
   b 树索引
   B+树索引
   B 树的所有节点既存放键(key) 也存放数据(data)，而 B+树只有叶子节点存放 key 和 data，其他内节点只存放 key。
   B 树的叶子节点都是独立的;B+树的叶子节点有双向链表连接起来的 范围查询。

2. 存储结构划分
   聚簇索引（聚集索引）：索引结构和数据一起存放的索引，InnoDB 中的主键索引就属于聚簇索引。非聚簇索引（非聚集索引）：索引结构和数据分开存放的索引，二级索引(辅助索引)就属于非聚簇索引。MySQL 的 MyISAM 引擎，不管主键还是非主键，使用的都是非聚簇索引。

- 数据库三大范式，什么是传递依赖
  列不可拆分
  非主键完全依赖于主键
  非主键只依赖于主键
- redis 为什么快

1. 基于内存实现 相比于在磁盘中去读取数据省去了耗时的磁盘 IO 操作
2. 各种经过精心优化过的数据结构如简单字符串空间优化，预分配空间和惰性空间释放，跳表，hash 表的渐进式的 rehash，压缩列表等
3. 单线程模式和 IO 多路复用，执行命令使用单线程，读写和协议解析使用多线程的方式使得 redis 的瓶颈是网络 IO 而不是 CPU,同时单线程很好的减少了上下文切换

- 为什么缓存使用 redis，而不是 jvm

- Redis 的 缓存击穿、雪崩、穿透场景以及解决方法
  == 和 equals 方法区别
  LinkedList 和 ArrayList 区别
- 深拷贝和浅拷贝区别
  浅拷贝复制引用属性时，仅仅复制指针值，没有复制指向的对象
  深拷贝完整复制一份该属性指向的对象 重写 clone 方法

  Java 中值传递的具体描述
  基本数据类型传递的就是基本类型的字面量值的拷贝，
  引用类型：引用类型在堆中地址的拷贝

  - 创建线程的方法
    Thread 类 runable 接口 callable 接口 run 方法 start 启动线程
    线程池的方法管理线程，
    线程创建的参数以及具体的工作流程
  - 生产者消费者模式
    用于解决多线程或多进程之间的协作和数据共享问题
    生产者负责生成数据、信息或任务，并将其放入共享缓冲区。
    消费者从共享缓冲区中取出数据并进行处理。

  - Java IO 流中使用的设计模式
    工厂模式（Factory Pattern）
    File file = new File("example.txt");
    装饰器模式
    添加额外的功能

  - 了解的设计模式：单例、工厂、生产者消费
    简单工厂模式：
    Spring 中的 BeanFactory 就是简单工厂模式的体现：
    一个工厂类根据传入的参数，动态决定应该创建哪一个产品类
    单例模式：
    Spring 依赖注入 Bean 实例默认是单例的
    双重校验锁
    两次检查的目的
    这确保了只有一个线程会创建实例。其他线程在第二次检查时会直接返回已创建的实例。

  - MySQL 索引的优缺点以及其底层的数据结构
    维护耗时 检索块 B+树
    使用过的性能测试的工具、
    jmeter
    出现 OOM 的原因，以及分析工具、分析方法、以及解决思路

- Redis 的具体使用到的场景
- 实习工作
  实习收获

- 1.自我介绍

  2.询问实习经历，介绍实习工作，提问实习项目如何优化

  3.扣项目，项目难点，如何实现？如何优化？能想到几种优化方案全都说？

  4.项目服务部署多份时，定时任务会出现的问题？如何解决？能给出两种以上的方案吗？

说了分布式锁，追问还有其他方案吗？继续回答了一些方案。

5.Redis 实现分布式锁你的理解和常见的应用场景？
保证数据的正确性：
比如：秒杀的时候防止商品超卖，表单重复提交，接口幂等性。
避免重复处理数据：
比如：调度任务在多台机器重复执行，缓存过期所有请求都去加载数据库。

互斥：同一时刻只能有一个线程获得锁。
可重入：当一个线程获取锁后，还可以再次获取这个锁，避免死锁发生。
高可用：当小部分节点挂掉后，仍然能够对外提供服务。
高性能：要做到高并发、低延迟。
6.MVC？SpringMVC?SpringMVC 的执行流程？拦截器在这个流程中如何？拦截器方法什时候执行？

7.SpringBoot 约定大于配置你的理解？

8.锁相关的东西，Lock 等

9. mysql 如何解决幻读问题的？
   隔离级别：串行化 或者使用 MVCC 10.多线程，
   是通过 MVCC 方式解决了幻读，因为可重复读隔离级别下，事务执行过程中看到的数据，一直跟这个事务启动时看到的数据是一致的，即使中途有其他事务插入了一条数据，是查询不出来这条数据的，所以就很好了避免幻读问题。

你是如何使用多线程的？有哪些注意事项？如何判断一个线程的任务已经执行结束？
继承 Tread 或者实现 Runable 和 Callbale 接口重写 run 或者 call 方法，

- 如何实现多个子线程中的任务先执行，之后在执行主线程的任务
  线程类自带的 join 方法，将子线程加入到主线程，在子线程执行完之后，在执行主线程逻辑
  join 当前线程等待调用执行 join 方法的线程执行完毕在继续
  启动方式 调用 start 方法
  或者用线程池的方式
  避免死锁，考虑创建多线程的性能消耗 使用线程池考虑线程之间的内存可见性
- 多线程唤醒

- .一道算法口述，大概就是给你一系列时间戳，找到某一月内出现两次以上的时间戳，答了 hashMap 记录，然后根据日期遍历 HashMap，以为是口述就大概讲讲思路，结果在一些细节问题上被抓时间戳如何换算日期什么的

- MySQL 索引，redis 数据结构，IO 多路复用，RabbitMQ
  IOC、AOP
  多线程，死锁，避免死锁
  HTTP 协议状态码
  springboot 作用
  9-19
- 介绍一下实习期间的项目，在项目里做了什么
  项目当中用了 java 中的什么 API，用了什么框架
  jvm 的原理了解吗，比如 jvm 生成类的过程，类的生命周期
  实习项目用的什么数据库
  实习当中设计过数据库表吗，谈谈怎么设计的
  怎么优化数据库的查询速度
  FTP 协议位于五层模型的哪一层
  二叉树前序遍历的算法，描述一下思路过程
  linux 下拷贝一个文件的命令，查看一个文件比如配置文件详细内容的命令
- 10-11
  1、面向对象的概念？
  面向对象，把构成问题的事务分解成各个对象，而建立对象的目的也不是为了完成一个个步骤，而是为了描述某个事件在解决整个问题的过程所发生的行为。 目的是为了写出通用的代码，加强代码的重用，屏蔽差异性。
  2、封装、继承、多态概念？
  封装是将数据和方法封装在类中；不允许外部对象直接访问对象的内部信息
  继承是允许子类继承父类的属性和方法；可以快速地创建新的类，可以提高代码的重用，程序的可维护性，节省大量创建新类的时间
  多态，表示一个对象具有多种的状态，具体表现为父类的引用指向子类的实例。
  3、Java 如何实现多态的？ Java 多态是同一个行为具有不同的表现形式，具体的实现方式是重载 重写父类引用指向子类对象 灵活 可扩充 消除类型之间的耦合关系
  4、Java 基本数据类型和引用类型？ float a = 1.2 报错默认是 double 会出现精度丢失 1.2f double = 5 不报错 短的
  引用类型 类 接口 数组枚举
  5、基本数据类型的包装类，为什么要用包装类？
  对基本数据类型的包装，使其具有对象的特性并增加了一些附加功能，使其更加灵活和实用，基本数据类型方便、简单、高效，但泛型不支持、集合元素不支持
  6、什么情况下用基本数据类型，什么情况用包装类？
  包装类 允许 null 这个字段允不允许 null 值，如果允许 null 值，则必然要用封装类
  7、String，为什么是引用类型？
  final 修饰的类
  String 真正不可变有下面几点原因：
  保存字符串的数组被 final 修饰且为私有的，并且 String 类没有提供/暴露修改这个字符串的方法。String 类被 final 修饰导致其不能被继承，进而避免了子类破坏 String 不可变。

  字符串对象通过“+”的字符串拼接方式，实际上是通过
  StringBuilder 调用 append() 方法实现的，拼接完成之后调用 toString() 得到一个 String 对象 。
  这意味着每循环一次就会创建一个 StringBuilder 对象。
  9、接口和抽象类的区别？
  通过关键字 abstract 定义的类叫做抽象类,抽象类中还能有不是抽象方法的方法
  接口通过关键字 interface 来定义
  抽象类可以有方法体的方法，但接口没有（Java 8 以前）。
  接口中的成员变量隐式为 static final，但抽象类不是的。
  一个类可以实现多个接口，但只能继承一个抽象类。

  10、什么时候用接口，什么时候用抽象类？（从继承、组合/聚合层面回答）

  组合体现的是整体与部分、拥有的关系，即 has - a 的关系 要利用多继承的优势。
  继承体现的是父与子，有一个层次的关系，即 is - a 的关系， 一些类提供公共的实现代码
  11、多线程，线程池的好处？
  12、设计模式，为什么要用？
  是一套被反复使用、多数人知晓的、经过分类编目的、代码设计经验的总结。
  使用设计模式是为了可重用代码、让代码更容易被他人理解、保证代码可靠性、程序的重用性

### 朗新科技

- Java 8 的改进
  只包含一个抽象方法的接口，称为函数式接口。

- springCloud 组件

- 熔断和降级的区别
  服务降级指的是当服务器压力剧增的情况下，根据当前业务情况及流量对一些服务和页面有策略的降级，以此释放服务器资源以保证核心任务的正常运行。
  熔断是应对微服务雪崩效应的一种链路保护机制
  降级的目的在于应对系统自身的故障，而熔断的目的在于应对当前系统依赖的外部系统或者第三方系统的故障。

- 消息队列中的应用场景、幂等、可靠性、顺序性等内容
  幂等： 创建消息记录表，并且添加 version 字段
  不重复消费 互斥锁 防止超卖 数据库的行锁

- SpringBoot 的自动装配
  通过注解或者一些简单的配置就能在 Spring Boot 的帮助下实现某块功能
  @SpringBootApplication 看做
  @Configuration、允许在上下文中注册额外的 bean 或导入其他配置类
  @EnableAutoConfiguration、启用 SpringBoot 的自动配置机制
  @ComponentScan 扫描被@Component 注解 bean，注解默认会扫描该类所在的包下所有的类。

. @EnableAutoConfigration：这个注解也是一个组合注解，里面有两个重要的注解

- @AutoConfigrationPage：将启动类及其同级或者子级的类给加载到 spring 容器中
- @Import：将需要配置的类一全限定名返回来
- Bean 的生命周期
  实例化（Instantiation）、属性赋值（Populate）、初始化（Initialization）、销毁（Destruction）。

- Synchronized 和 Lock 区别

- Mysql 日志
  binlog 二进制日志 记录数据库所有的更改操作，主要用于数据的备份和恢复
  redo log 重做日志 保存了事务的持久性 用于数据宕机后的数据恢复
  undo log 回滚日志 保证了事务的原子性，用于事务的回滚和 MVCC
  redo log undo log 是 mysql 中 innodb 引擎独有的
  当数据库宕机后，mysql 根据 redolog 进行恢复数据库，保持数据的持久性。记录了数据提交后的数据状态
  undo log 回滚日志 记录了在事务提交之前的数据状态

1. 在事务为提交之前 记录数据到 undo log 中去 当事务回滚时根据 undo log 进行回滚、
2. 实现 MVCC 通过 Read view +undo log 实现 MVCC

- 限流
  利用缓存保存每个 id 用户在特定时间内的访问次数，超过则返回提升信息。

### 同盾

- 聊一下最熟悉的项目吧
  购票系统的流程

  - 如何防止限流
    接口限流、分布式锁的演变
  - 如何防止重复下单
  - 如何减库存 扣减库存保证数据一致性

- 栈和队列的区别

  - 队列允许中间操作吗
  - LinkedList 是队列还是栈
  - LinkedList 如何删除中间的节点
  - LinkedList 删除的时间复杂度
    LinkedList 的 remove 方法的检索时间复杂度为 O ( n ) {准确说是 O ( n / 2 ) O(n/2)O(n/2) }，删除的时间复杂度为 O ( 1 )。
  - LinkedList 删除操作的步骤
  - ArrayList 的删除操作
  - 需要删除拷贝机制吗

- 线程

  - 状态
  - 线程什么时候挂起
  - 挂起后如何唤醒
  - 什么是线程池
  - 线程池的默认拒绝策略
  - 可以创建核心线程数大于最大线程数的线程池吗 核心线程数=8 最大线程数是 4 那么运行的线程数目是多少
  - 线程池有任务在运行后重启之后会有什么影响

- Java 锁
- 乐观锁介绍
- \*\*如何用数据库实现乐观锁 -数据库行锁在项目中的实现
  描述多线程下的乐观锁流程
- 线程池有任务在运行后重启之后会有什么影响
- 如何自己实现 CAS
- 多线程下如何保证 CAS 乐观锁拿到相同的版本号怎么办
- MYSQL 的 MVCC 作用和原理

- \*\*MVCC 实现原理 删除 添加时的版本号会改变吗
  MVCC 修改数据会产生几个版本
  删除呢
- 索引类型和数据结构
- 聚簇索引和非聚簇索引
- 覆盖索引
- 覆盖索引是和存储引擎相关吗
- \*\*myisam 的索引需要回表吗
- Linux 命令
- 对目录进行授权
- 对子目录进行修改权限

### HR

#### 你的职业规划是什么

首先我热爱技术，同时我也意识到技术和知识的重要性，我希望自己 3 年内能够扎根自己的岗位职责，努力做好技能提升和学习，让自己成为出色的 Java 开发领域的专家。
其次珍惜公司提供的平台，不断了解公司的业务发展需求，更好地理解技术与业务之间的关联，在岗位中成为独当一面的人才，在匹配公司发展的前提下，做到专业深耕，为公司做出属于自己的出色贡献。

#### 优缺点

缺点：缺少管理能力，对部分问题的细节等处理经验有待加强
优点：有计划的学习，有较强的学习能力和学习主动性，处事耐心

### 如何谈薪资

提问企业发展情况，行业情况、
入职后的员工培养

薪资是个人价值的体现，是对我之前面试的肯定，也是体现我自我价值的体现，作为应届生我并不将收入的高低作为入职的标准 ，我希望了解下公司的薪资标准 发几个月 奖金 五险一金 公积金的比例
针对我之前的面试经验来看，我觉得一万三千左右是我期望的薪资
比起基础工资，我更想了解一下公司的薪酬结构，五险一金缴纳的基础是否和工资一样，每个月除了基本工资，是否还有额外的绩效和提成，是否会有加班，加班费如何计算，公司是否有年终奖，年终奖和 KPI 考核机制是怎样的

### 苏州银行 AI 面试

- 自我介绍
  自我介绍至少包括“校园经历”和“社会实践”两部分
  面试官您好，我是 2024 届汕头大学计算机专业的硕士研究生，本科就读于 安徽工程大学的软件工程专业。在本科阶段和研究生阶段我获得过多次奖学金并通过了六级考试，同时发表了一篇 sci 论文，在专业知识方面我深入了解过 Java 集合并发编程，MySQL、Redis 等相关的内容，在学校阶段我负责过汕头大学 P3 级生物实验室项目的开发并担任校内开发组长，负责和校内老师需求的沟通，校外开发人员需求的沟通，校开发人员任务的分配，前后端联调，部分接口的编写。同时和导师一起 参与汕头市练江水质检测管理整治项目，并根据当地监测站信息搭建机器学习平台，利用监测站数据对练江某监测站数据做预测，并证明了所搭建的机器学习平台的有效性， 根据实验数据撰写并发表 sci 论文一篇。在社会实践阶段 ，今年的六月到九月我在亚信科技有限公司做过 Java 开发实习生的工作（实习经历），所在部门负责中国移动 APP 拉端搜索相关业务的开发，之前还做过一个关于学生购票和博客分享方面的项目。在简历投递之前我了解到咱们公司是行业领先的企业管理软件及电子商务应用解决方案供应商，拥有强大的创新能力和丰富的业务经验，对此我非常希望能够得到在这里学习和成长的机会，并继续从事 Java 开发方向的工作。那么这里的我的自我介绍完毕。

- 职业规划
  加入银行的职业规划
  职业规划至少包括三个阶段，及“从学生到职场人”“从职场新人到职场骨干”“从职场骨干到基层管理者”，各个阶段都要结合岗位说清楚“我要用多长时间”“我要怎么做”“我要达到的目标”。

  我非常激动有机会加入银行科技团队，我充满热情并有着明确的职业生涯规划。以下是我对未来职业发展的展望和规划：

  从学生到职场人阶段：作为银行科技领域的一员，我意识到技术和行业知识的重要性。我计划使用一年左右的时间，通过参加行业培训和研讨会，持续学习最新的技术趋势和发展，并获取相关的认证。我将不断提升自己的技术技能，以应对不断变化的科技挑战。加深对金融科技领域的理解

从职场新人到职场骨干：我计划用两到三年的时间，积极参与银行科技团队的项目，并尽力提供高质量的解决方案，主动承担并挑战更高难度的工作内容。我将努力和团队成员合作，共同解决问题和实现目标。在项目中，我将尽可能发挥自己的优势，并不断追求创新和卓越。

从职场骨干到管理者：为了更好地履行银行科技岗位的职责，我将深入了解银行的业务流程和需求。这将有助于我更好地理解技术与业务之间的关联，从而提供更贴合实际情况和用户需求的解决方案
领导与管理能力的发展：我对拓展我的领导和管理能力充满热情 0。在未来，我期望能够承担更多的责任，带领团队完成重要项目，并协助新员工的成长。我将积极寻找培训和导师资源，不断提升我的领导和沟通技能。

跨部门合作：除了在银行科技团队内部的成长，我也将积极与其他部门合作。与风险管理、业务发展和客户服务等团队紧密合作，协同解决问题和实现共同目标。

最重要的是，我希望能够在银行科技领域发挥出最佳的潜力，并为公司的成功贡献力量。我相信，通过不断学习和努力工作，我能够实现自己的职业目标，并与公司一起取得共同的成就。

## 宇视科技

- 自我介绍
  面试官您好，我是 2024 届汕头大学计算机技术专业的硕士研究生，本科就读于 安徽工程大学的软件工程专业，在本科阶段和研究生阶段我获得过多次奖学金并通过了六级考试，同时发表了一篇 sci 论文，在专业知识方面我深入了解过 Java 集合并发编程，MySQL、Redis 等相关的内容，今年的六月到九月我在亚信科技做过 Java 开发实习生的工作（实习经历），所在部门负责中国移动 APP 拉端搜索相关业务的开发，之前还做过一个关于学生购票和博客分享方面的项目。在简历投递之前我了解到咱们公司是一家专研生活电器领域的智能科技创新公司，拥有强大的创新能力和丰富的业务经验，对此我非常希望能够得到在这里学习和成长的机会，并继续从事 Java 开发方向的工作。那么这里的我的自我介绍完毕。
- 项目描述

这是一个模拟了高并发场景的抢票系统，它具备登陆和抢购的功能，并在经过几个版本的迭代之后成为支持高并发的抢票系统。为了解决用户抢购场景下的高并发问题。引入了 redis 作为缓存中间件，主要作用是 完成 sessionID 的共享，缓存预热、预减库存等等。针对抢购进行了接口限流 、redis 预减库存，消息队列异步消费，请求路径动态创建等优化。通过 Jmeter 压力测试，系统的 QPS 从 150/s 提升到 2000/s。

- Redis 预减库存

主要思路减少对数据库的访问，不需要直接访问数据库，当高并发请求到来的时候，大量的读取数据有可能会导致数据库的崩溃

1. 系统初始化的时候，将商品库存加载到 Redis 缓存中保存
2. 收到请求的时候,先在 Redis 中拿到该商品的库存值，进行库存预减，如果减完之后库存不足，直接返回逻辑 Exception 就不需要访问数据库再去减库存了，如果库存值正确，进行下一步
   将请求入队，立即给前端返回一个值，表示正在排队中，然后进行下单逻辑，后端队列进行下单，前端轮询后端发来的请求，如果秒杀成功，返回秒杀，成功，不成功就返回失败。

- 数据一致性 下单保证 redis 的数据和数据库一致 项目的难点

应该：写操作执行时先操作数据库在删除缓存 ，当查询时缓存为空需要从数据库中读取并更新缓存
先写缓存再写数据库 后写的数据会产生脏数据

下单保证原子性
开启 Spring 事务功能

- 接口限流
  拦截器拦截请求，用户每点击一次请求按钮，都会在用户 id 的缓存请求 key 中记录访问次数，查看是否有接口限流的注解，得到限流信息，并提取 request 的请求地址和用户 id 和访问路径组合为 key 作为用户的唯一标示符，value 为访问次数，通过查询访问次数是否合法来决定是否对请求进行放行，

- 追问：Spring 事务 如何失效何时失效

@Transactional 开启事务，如果执行异常则进行回滚

1. 方法不是 public ，申明式事务基于 AOP 通过代理模式实现，只有 public 方法才能被访问和调用。使用了 final 修饰
2. 方法内部调用没有使用代理对象
3. 类未被 spring 管理
4. 异常被捕获并处理 事务检测不到异常 无法判断是否回滚自己比较熟悉的一个设计模式

### 用户登录验证

JWT 是一种基于 token 的认证流程实现，主要结合 SpringSecurity 生成 token

- 客户端向服务器端发送用户名和密码
- 服务器端验证通过后，在当前会话（session）中保存相关数据，比如说登录时间、登录 IP 等。
- 服务器端向客户端返回一个 session_id，客户端将其保存在 Cookie 中。
- 客户端再向服务器端发起请求时，将 session_id 传回给服务器端。
- 服务器端拿到 session_id 后，对用户的身份进行鉴定

> 使用 JWT 和 Session 的区别
> JWT 需要每次请求的时候验证一次，并且只要 JWT 没有过期，哪怕服务器端重启了，认证仍然有效。
> Session 在没有过期的情况下是不需要重新对用户信息进行验证的，当服务器端重启后，用户需要重新登录获取新的 Session

2. 用户的登陆时登陆失败问题

- jvm 的参数
- 设计模式
  设计模式是在软件开发中经常出现的问题的常见解决方法的模板。这些模式是经过多年的实践和经验总结出来的，可以帮助开发人员更有效地解决问题，并提高代码的可维护性和可扩展性。设计模式不是特定的代码或库，而是一种通用的解决问题的方法论，可以应用于不同的编程语言和项目。
  Spring 中常见的设计模式

  - 简单工厂模式
    根据传入一个唯一的标识来获得 Bean 对象，但是否是在传入参数后创建还是传入参数前创建这个要根据具体情况来定
  - 工厂方法
    即应用程序将对象的创建及初始化职责交给工厂对象。
  - 单例模式
    Spring 的容器（如 ApplicationContext）通常使用单例模式来管理 bean 对象。这意味着在应用程序的整个生命周期内，每个受 Spring 管理的 bean 都只有一个实例。

- 模板模式
  Spring 中 JdbcTemplate、RestTemplate 等以 Template 结尾的对数据库、网络等等进行操作的模板类，就使用到了模板模式。
- 网络

- 了解哪几种锁，读写锁有什么特性
  Mysql 中有哪几种锁 悲观锁，乐观锁，表锁，页锁 行锁，按照兼容性划分分为分为排他锁 X 锁 也叫写锁 写锁相互阻塞 共享锁 也叫读锁 S 锁 不相互阻塞

  悲观锁 ：写锁 行锁 更新票库存的信息为行锁
  乐观锁 ：库存检查大于 0 即可

- 共享内存在应用上需要注意的点有哪些
  注意数据一致性，死锁，内存泄漏：
- 进程间的通信方式
  volatile 和 synchronized 关键字，volatile 可以用来修饰字段（成员变量），程序任何对该变量的访问均需要从共享内存中获取，而对它的改变必须同步刷新回共享内存，它能保证所有线程对变量访问的可见性
  等待/通知机制
  可以通过 Java 内置的等待/通知机制（wait()/notify()）实现一个线程修改一个对象的值，而另一个线程感知到了变化，然后进行相应的操作。
  使用 Thread.join()
  使用 ThreadLocal 保存进程的上下文信息

- 一面：
  Linux 的文件搜索命令
  find:查找指定目录下的文件
  格式：find 目录 参数
  任何位于参数之前的字符串都视为目录
  locate 命令
  - Spring 的设计模式
  - Java 的深拷贝和浅拷贝的区别
    浅拷贝创建的新的对象的字段和原始对象字段相同，若原始对象有引用类型则他们共享引用类型的对象。
    深拷贝 不仅会复制原始对象的字段同时复制引用类型的对象，修改原始对象新对象不受影响。

## 民生科技

- 自我介绍
  面试官您好，我是 2024 届汕头大学计算机技术专业的硕士研究生，本科就读于 安徽工程大学的软件工程专业，在本科阶段和研究生阶段我获得过多次奖学金并通过了六级考试，同时发表了一篇 sci 论文，在专业知识方面我深入了解过 Java 集合并发编程，MySQL、Redis 等相关的内容，今年的六月到九月我在亚信科技做过 Java 开发实习生的工作（实习经历），所在部门负责中国移动 APP 拉端搜索相关业务的开发，之前还做过一个关于学生购票和博客分享方面的项目。在简历投递之前我了解到咱们公司是致力于科技创新提供科技金融科技综合服务的公司，拥有强大的创新能力和丰富的业务经验，对此我非常希望能够得到在这里学习和成长的机会，并继续从事 Java 开发方向的工作。那么这里的我的自我介绍完毕。
- 项目描述

这是一个模拟了高并发场景的抢票系统，它具备登陆和抢购的功能，并在经过几个版本的迭代之后成为支持高并发的抢票系统。为了解决用户抢购场景下的高并发问题。引入了 redis 作为缓存中间件，主要作用是 完成 sessionID 的共享，缓存预热、预减库存等等。针对抢购进行了接口限流 、redis 预减库存，消息队列异步消费，请求路径动态创建等优化。通过 Jmeter 压力测试，系统的 QPS 从 150/s 提升到 2000/s。

- Redis 预减库存

主要思路减少对数据库的访问，不需要直接访问数据库，当高并发请求到来的时候，大量的读取数据有可能会导致数据库的崩溃

1. 系统初始化的时候，将商品库存加载到 Redis 缓存中保存
2. 收到请求的时候,先在 Redis 中拿到该商品的库存值，进行库存预减，如果减完之后库存不足，直接返回逻辑 Exception 就不需要访问数据库再去减库存了，如果库存值正确，进行下一步
   将请求入队，立即给前端返回一个值，表示正在排队中，然后进行下单逻辑，后端队列进行下单，前端轮询后端发来的请求，如果秒杀成功，返回秒杀，成功，不成功就返回失败。

- 数据一致性 下单保证 redis 的数据和数据库一致 项目的难点

应该：写操作执行时先操作数据库在删除缓存 ，当查询时缓存为空需要从数据库中读取并更新缓存
先写缓存再写数据库 后写的数据会产生脏数据

下单保证原子性
开启 Spring 事务功能

- 接口限流
  拦截器拦截请求，用户每点击一次请求按钮，都会在用户 id 的缓存请求 key 中记录访问次数，查看是否有接口限流的注解，得到限流信息，并提取 request 的请求地址和用户 id 和访问路径组合为 key 作为用户的唯一标示符，value 为访问次数，通过查询访问次数是否合法来决定是否对请求进行放行，

- 追问：Spring 事务 如何失效何时失效

@Transactional 开启事务，如果执行异常则进行回滚

1. 方法不是 public ，申明式事务基于 AOP 通过代理模式实现，只有 public 方法才能被访问和调用。使用了 final 修饰
2. 方法内部调用没有使用代理对象
3. 类未被 spring 管理
4. 异常被捕获并处理 事务检测不到异常 无法判断是否回滚自己比较熟悉的一个设计模式

5. 实习的收获
6. 银行使用 chatgpt 的看法: 金融与科技融合是科技推动下社会分工深化的必然趋势，ChatGPT 无疑将拓宽金融领域 AI 应用的边界，极大推动金融行业变革，助推金融机构更好地服务实体经济.一是具备超强的“人类反馈”学习能力,。二是具备超强的语言重组创造能力.三是具备超强的拟人情感能力.
   应用场景：一是智能客服。二是智能营销，精准推送内容。数据智能挖掘和理解。反诈骗，提升防控的精准性。辅助编写代码
7. 银行金融科技岗的理解
   金融科技的重点在于技术变革，是用大数据、人工智能、区块链等一系列的技术，去为金融机构服务。
8. 八股文，数据结构（排序算法、二叉树）、计网（TCP 和 UDP）、操作系统、MySQL（索引、三大范式）
9. BIO、NIO、AIO？
   是 Java 中用于处理 I/O 操作的不同模式。
10. 项目的开发流程
    项目启动阶段
    需求阶段
    设计阶段
    开发阶段
    测试阶段
    常规文档
    2022

11. 原码，补码，反码及应用场景
    表示整数的三种不同方式
    原码 最高位表示符号位 加减需要考虑符号位
    反码 正数反码和原码相同 负数是除符号位每一位取反解决原码 0 的正负问题
    补码 正数补码和原码相同 负数将原码取反加一这样加减法统一 不需要处理符号位 因此补码最常用
12. Java 死锁（一个人，其他同学补充提问）tcp 建立连接的过程
    死锁两个或两个以上的线程在执行过程中，因争夺资源而造成的互相等待的现象，无外力情况下不能继续进行下去。死锁必要条件：互斥 请求保持 循环等待 资源不可剥夺
    预防死锁：破坏除了互斥之外的三个条件 之一
    破坏请求与保持条件：一次性申请所有的资源。
    破坏不剥夺条件：占用部分资源的线程进一步申请其他资源时，如果申请不到，可以主动释放它占有的资源。
    破坏循环等待条件：靠按序申请资源来预防。按某一顺序申请资源，释放资源则反序释放。破坏循环等待条件。
13. 请求一个 URL 的过程，连接到一个页面的过程

进程间通信方式

### 从浏览器地址栏输入 url 到显示主页的过程？

- DNS 协议解析 将域名解析成对应的 IP 地址。
  - DNS 解析：
    若本地服务器中有对应的 IP 地址缓存则直接返回，否则本地 DNS 服务器将向根域名服务器发送请求，找到顶级域名服务器在通过顶级域名服务器找到权限域名服务器得到最终的 Ip 地址
- TCP 连接：与服务器通过三次握手，建立 TCP 连接
- 向服务器发送 HTTP 请求
- 服务器处理请求，返回 HTTP 响应
- 浏览器解析并渲染页面
- 断开连接：TCP 四次挥手，连接结束

10. 如果时间复杂度为 O(n)，如何找出第二大的元素，不考虑排序算法（双指针）
    通过存储最大和第二大的数据 从头到尾遍历一遍数组
11. 说一下你们理解的继承和多态？
12. 自己比较熟悉的一个设计模式
    单例模式
13. 堆排序的过程
14. 数据库的三个范式
15. 说一下 TCP 和 UDP 的区别
16. 说一说 volatile 关键字
17. UDP,TCP 区别
    8.TCP 为什么三次握手
    9.TCP 为什么四次挥手，最后一次要等 2msl
18. 常用的 Linux 命令
    ls 列出目录内容
    cd: 更改当前工作目录 cd ..: 进入上级目录 cd ~: 进入当前用户的家目录
    pwd: 显示当前工作目录的路径
    mkdir 新建工作目录
    rm: 删除文件或目录
    mv: 移动文件或重命名文件
    cat 显示文件内容
    sudo: 以超级用户或其他用户的身份执行命令
    chmod: 更改文件或目录的权限 chmod -R 777（用户 群组 其他）文件
    r 4 w 2 x 1

### 慢查询优化

pagehelper 数据量达到一定数量时 limit 分页时会特别慢，count（\*）把数据库卡死 pagehelper 用 selectAll 时会帮你做个 select count(0)上千万数据时 10 分钟回不来

limit 深分页问题 丢弃 offset 前的数据再返回后 n 行记录需要多次回表 造成越查询越慢

标签记录法 游标标记法 每次从上一页的末尾开始查询 不存在深分页问题 不能够随机查询
优化 ： 走索引 最左匹配 联合索引 定义主键
聚簇索引 (clustered index)：聚簇索引的叶子节点存储行记录，InnoDB 必须要有且只有一个聚簇索引：

如果表定义了主键，则主键索引就是聚簇索引；
如果没有定义主键，则第一个非空的唯一索引列是聚簇索引；
如果没有唯一索引，则创建一个隐藏的 row-id 列作为聚簇索引。主键索引查询非常快，可以直接定位行记录。
非聚簇索引 （secondary index)：InnoDB 非聚簇索引的叶子节点存储的是行记录的主键值，而 MyISAM 叶子节点存储的是行指针。
通常情况下，需要先遍历非聚簇索引获得聚簇索引的主键 ID，然后在遍历聚簇索引获取对应行记录
