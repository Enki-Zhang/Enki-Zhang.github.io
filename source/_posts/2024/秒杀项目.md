---
title: 秒杀项目
top: false
cover: false
toc: true
mathjax: true
date: 2024-01-11 09:35:22
password:
summary:
tags:
categories:
---

面试官您好，我是 2024 届汕头大学计算机技术专业的硕士研究生，本科就读于 安徽工程大学的软件工程专业，在本科阶段和研究生阶段我获得过多次奖学金并通过了六级考试，同时发表了一篇 sci 论文，在专业知识方面我深入了解过 Java 集合并发编程，MySQL、Redis 等相关的内容，今年的六月到九月我在亚信科技做过 Java 开发实习生的工作（实习经历），所在部门负责中国移动 APP 拉端搜索相关业务的开发，之前还做过一个关于学生购票和博客分享方面的项目。在简历投递之前我了解到咱们公司是从事金融科技行业相关的公司，拥有强大的创新能力和丰富的业务经验，对此我非常希望能够得到在这里学习和成长的机会，并继续从事 Java 开发方向的工作。那么这里的我的自我介绍完毕。

### 流程

将参与秒杀的商品缓存到 redis 中，并设置内存标记每个商品是否有库存，当用户点击秒杀按钮是前端发送请求，后端根据每位用户生成唯一的秒杀路径，并存入到 redis 中，前端将路径进行拼接为新的 url，发送给后端并进行路径校验，进行秒杀，先查询内存标记有库存在查询 redis 进行预减，当 redis 库存小于 0 后，返回失败，否则将请求放入到消息队列中进行排队，从队列中取出订单并更新数据库，创建订单并完成秒杀。

## 登陆

- 无状态登陆
  进行用户身份验证（登录）时，服务器不保存用户的登录状态信息，而是在每个请求中都重新进行身份验证，而无状态登录通常使用令牌（Token）来实现。用户在登录成功后，服务器生成一个令牌并发送给客户端，客户端在后续的请求中带上这个令牌。服务器通过验证令牌来确定用户的身份，而不需要在服务器端保存用户的登录状态信息。因此，无状态登录更适合分布式系统和微服务架构，因为它不依赖于在各个服务之间共享会话信息。

## 如何解决超卖问题

- 在 sql 加上判断防止数据变为负数
- 数据库加唯一索引防止用户重复购买
- redis 预减库存减少数据库访问　内存标记减少 redis 访问　请求先入队列缓冲，异步下单，增强用户体验

1. 通常在扣减库存的场景下使用行级锁，通过数据库引擎本身对记录加锁的控制，保证数据库的更新的安全性，并且通过 where 语句的条件，保证库存不会被减到 0 以下。意思是在 sql 语句对数据库进行操作时候进行控制。
2. 通过对库存字段设置为无符号型 那么出现负数则报错。
   简单的在操作数据库的时候给 SQL 语句加上限定只有库存量大于 0 才能够减库存
   内存标记并预减库存
   超卖现象是多线程安全问题，使用乐观锁

## 预减库存 \*\*

使用 Redis 预减库存主要是为了做什么呢,就是它能解决什么问题
主要目的减少对数据库的访问,可以拦截卖完了之后多余的请求，防止多个请求不断达到数据库造成压力，同时不需要考虑库存数据一致性
实现思路：

1. 先将商品信息加载到 Redis 缓存中
2. 当收到秒杀请求时，在访问 Redis 之前先在内存标记中获取对应商品的库存数量，做到不需要对 Redis 进行访问就得到了库存，减少了高并发下的 Redis 压力，再判断 Redis 中的缓存商品数量预减并判断是否足够，不足则直接返回异常，并标记内存库存不足。
3. 否则将订单信息发送到消息队列中，并返回前端成功标志，之后队列消费依次创建秒杀订单完成秒杀，前端进行轮询判断是否秒杀成功。

> session 和 cookie

## 分布式 session

- 生成随机的 uuid 作为 cookie 返回并 redis 内存写入
- 拦截器每次拦截方法，来重新获根据 cookie 获取对象
- 下一个页面拿到 key 重新获取对象
- HandlerMethodArgumentResolver 方法 supportsParameter 如果为 true 执行 resolveArgument 方法获取 miaoshauser 对象
- 如果有缓存的话 这个功能实现起来就和简单，在一个用户访问接口的时候我们把访问次数写到缓存中，在加上一个有效期。
- 通过拦截器. 做一个注解 @AccessLimit 然后封装这个注解，可以有效的设置每次访问多少次，有效时间是否需要登录！

## 秒杀库存如何防止超卖

扣减库存时候，要保证数据库中的字段值不能为负数，

1. 通常在扣减库存的场景下使用行级锁，通过数据库引擎本身对记录加锁的控制，保证数据库的更新的安全性，并且通过 where 语句的条件，保证库存不会被减到 0 以下。意思是在 sql 语句对数据库进行操作时候进行控制。
2. 通过对库存字段设置为无符号型 那么出现负数则报错。

### 缓存击穿问题

热点 key 失效问题，高并发访问的 key 失效，大量的访问请求达到了数据库
方法：

1. 缓存预热：在项目中先将商品信息在项目启动时便加载到 redis 中；
   实现方式：
   秒杀 controller 中实现 InitializingBean 方法会在 Bean 初始化后将商品对应的库存缓存到 redis 中。Springboot 的 Bean 的默认作用域是单例的，因此会在项目启动时加载初始化 Bean
2. 互斥锁 使用 Redission 互斥锁，每个线程的请求均需要拿到锁，这样保存线程一次只有一个线程来请求数据，不会出现大量请求失效的问题。但是使用互斥锁的项目性能不能保证，会降低系统的吞吐量。
3. 逻辑过期
4. 热点 key 永不过期 实际上热点数据是商品的信息，当商品过期也就意味着缓存中的数据没有意义，因此设置热点 key 过期时间和秒杀过期时间一致
5. 在缓存上实现接口限流
   在秒杀接口等重要接口上做好限流策略，同时使用缓存预减库存即使判断数据库存，快速失败。

## rabbitmq 如何做到消息不重复不丢失即使服务器重启

## 分布式锁

> 在分布式系统环境下，一个方法在同一时间只能被一个机器的一个线程执行；
> 高可用的获取锁与释放锁；
> 高性能的获取锁与释放锁；
> 具备可重入特性；
> 具备锁失效机制，防止死锁；
> 具备非阻塞锁特性，即没有获取到锁将直接返回获取锁失败。

- 基于缓存（Redis 等）实现分布式锁；

## 重复下单

### 数据一致性

- 分为更新缓存

  - 更新数据库后再更新缓存
    线程 A 将数据库中 1->2 线程 B 将 2->3 当线程 A 更新数据库后，此时线程 B 继续尝试更新，但 B 线程更新速度较快使得 A 线程未结束时缓存已经更新为 3,此时 A 线程尝试更新缓存错误的将 3 变更为 2；造成缓存数据不一致
  - 先更新缓存再更新数据库
    线程 A 先将缓存改变为 2，此时线程 B 会再线程 A 走到数据库之前进行更新，将缓存改为 3，数据库改为 3，此时线程 A 来到数据库中修改数据为 2,即最终缓存为 2，数据库为 3，数据不一致；

- 删除缓存

  - 先删除缓存再更新数据库，再查询的时候去更新缓存
    线程 A 先删除缓存，后去到数据库中还未更新，此时线程 B 已经拿到了旧的数据并更新到了缓存中去，当 A 线程更新数据库完毕后,缓存和数据库已经不一致；
  - 先删除缓存在更新数据库，在删除缓存
    称之为`延迟双删`，在读线程写入到缓存中之后，在删除一次缓存，但有时候第二次删除可能在读线程写入缓存的前面，致使二次删除无效，因此，二次删除需要延迟进行并确保在读请求写入缓存之后进行。
  - 先更新数据库，再删除缓存，在查询的时候去更新缓存
    此时在更新数据和查询数据的间隙中可能会出现短暂缓存不一致问题。

应该：写操作执行时先操作数据库在删除缓存 ，当查询时缓存为空需要从数据库中读取并更新缓存
先写缓存再写数据库 后写的数据会产生脏数据

**修改内容时间：** 2023 年 12 月 30 日

## 限流

> TPS 和 QPS
> TPS（Transactions Per Second）是一个衡量系统性能的指标，用于表示系统在单位时间内能够处理的事务数量。

> QPS（Queries Per Second）是一个衡量系统负载或性能的指标，用于表示系统在单位时间内处理的查询请求数量。

### 常见限流算法

解决高并发请求数据库问题，

- 固定窗口算法
- 滑动窗口算法
- 令牌桶算法
- Guava RateLimiter：基于令牌桶算法实现了简单且高效的限流

由于 RateLimiter 是属于单位时间内生成多少个令牌的方式，该用户在某段时间内，还有没有机会得到令牌，这里就需要使用 tryAcquire(long timeout, TimeUnit unit)方法，指定一个超时时间，一旦判断出在 timeout 时间内还无法取得令牌，就返回 false。

## 缓存问题

- 缓存击穿 较大并发访问的 key 失效，导致访问请求直接达到了数据库
  方法：
  使用互斥锁，只有拿到这把互斥锁的线程可以进数据库请求数据，其他线程等待，待该线程查到数据存入缓存后其他线程直接使用缓存中的数据
- 缓存穿透： 缓存穿透指的查询缓存和数据库中都不存在的数据，这样每次请求直接打到数据库，就好像缓存不存在一样。
  方法：
  缓存 null 值
  布隆过滤 布隆过滤器里会判断数据是否存在，如果判断数据不不能再，就不会访问存储
  增强 id 的复杂度，避免被猜测 id 规律
  做好数据的基础格式校验
  加强用户权限校验
  做好热点参数的限流

- 缓存雪崩 某⼀时刻发⽣⼤规模的缓存失效的情况 例如缓存服务宕机、大量 key 在同一时间过期，这样的后果就是⼤量的请求进来直接打到 DB 上，可能导致整个系统的崩溃，称为雪崩
  方法：
  给不同的 Key 的 TTL 添加随机值
  利用 Redis 集群提高服务的可用性
  给缓存业务添加降级限流策略
  给业务添加多级缓存

### 慢查询优化

pagehelper 数据量达到一定数量时 limit 分页时会特别慢，count（\*）把数据库卡死 pagehelper 用 selectAll 时会帮你做个 select count(0)上千万数据时 10 分钟回不来

limit 深分页问题 丢弃 offset 前的数据再返回后 n 行记录需要多次回表 造成越查询越慢

标签记录法 游标标记法 每次从上一页的末尾开始查询 不存在深分页问题 不能够随机查询
优化 ： 走索引 最左匹配 联合索引 定义主键
聚簇索引 (clustered index)：聚簇索引的叶子节点存储行记录，InnoDB 必须要有且只有一个聚簇索引：

如果表定义了主键，则主键索引就是聚簇索引；
如果没有定义主键，则第一个非空的唯一索引列是聚簇索引；
如果没有唯一索引，则创建一个隐藏的 row-id 列作为聚簇索引。主键索引查询非常快，可以直接定位行记录。
非聚簇索引 （secondary index)：InnoDB 非聚簇索引的叶子节点存储的是行记录的主键值，而 MyISAM 叶子节点存储的是行指针。
通常情况下，需要先遍历非聚簇索引获得聚簇索引的主键 ID，然后在遍历聚簇索引获取对应行记录

## 使用 Redission 分布式锁解决抢座中的超卖和重复下单问题，并解决了 Redis 宕机时可能出现的锁死情况。

这里可能出现的死锁情况是，分布式锁未表明超时时间从而导致死锁

在 Redis 宕机的情况下，分布式锁可能会发生死锁的情况，这主要取决于锁的实现方式和程序中对于异常情况的处理。

在使用 Redis 实现的分布式锁中，通常是通过设置一个带有过期时间的键（锁）来实现的。当一个客户端获取到锁时，会设置该键的过期时间，确保即使客户端在某些情况下异常退出，锁最终会自动释放。然而，当 Redis 宕机时，锁的过期时间无法被正常更新，可能导致锁一直存在而不会被释放，这就是一种死锁情况。

为了避免在 Redis 宕机时出现死锁，可以考虑以下策略：

设置适当的锁超时时间： 设置锁的过期时间不要太长，以确保即使 Redis 宕机，锁也能够在相对短的时间内自动释放。

实现锁续约机制： 在锁即将过期时，通过续约操作来更新锁的过期时间。这需要在程序中定期执行锁的续约操作，确保锁在持有期间内一直有效。

使用可靠的锁实现： 选择使用经过验证、在 Redis 宕机等异常情况下表现可靠的分布式锁实现。例如，Redisson 等工具库提供了对分布式锁的支持，能够处理宕机等异常情况。

总体来说，确保分布式锁的可靠性需要综合考虑锁的过期时间、续约机制以及对 Redis 宕机等异常情况的处理。

## 加密算法
