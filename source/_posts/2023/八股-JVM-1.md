---
title: JVM
top: false
cover: false
toc: true
mathjax: true
date: 2023-09-22 14:15:27
password:
summary:
tags: 八股
categories: JVM
---

### 了解 JVM 内存结构、垃圾回收等内容

JVMd 的主要作用是在不同的计算机平台上执行 Java 字节码。

### JVM 内存结构 运行时数据区域

java 虚拟机在执行 Java 程序时将内存划分成不同的数据区域

- 线程私有
  - 程序计数器
    当前线程执行的字节码的行号器，通过改变
  - 虚拟机栈
    描述 Java 方法执行线程的内存模型，当方法被调用时会创建栈帧，保存了方法调用的上下文信息包括局部变量表，操作数栈、动态链接等内容，当方法返回时栈帧被销毁
  - 本地方法栈
    作用和虚拟机栈类似，但是保存的是 native 方法的调用信息
- 线程共享
  - 堆 ：目的是存放对象的实例，所有对象和数组均在堆中开辟内存，同时堆也是垃圾收集的主要区域。根据垃圾回收的角度，堆分为新生代内存、老生代、永久代
  - 方法区 存储被虚拟机加载的类信息，字段信息，方法信息，常量，静态变量等数据

### GC

已经有了 GC 为什么还要了解 GC 的机制呢？
当垃圾回收是项目并发的瓶颈时，我们需要去对其进行监控和调优。

- 可达性分析：用于确定那些对象能够进行回收
  当对象到 GCRoot 间没有任何引用链路相连，则该对象不再被使用。需要被回收
  固定可作为 GC Roots 的对象：
  在虚拟机栈（栈帧中的本地变量表）中引用的对象
  方法区类的静态属性引用对象、常量引用对象
  本地方法栈中 JNI 引用对象
  synchronized 关键字修饰的对象

**如何决定是否死亡**
当对象不可达时为第一次标记，第二次标记对象没有覆盖 finalize 方法，或 finalize 方法已经被虚拟机调用过时，虚拟机将这两种情况视为没有必要执行。否则进入 F-Queue 中且最终方法没有和引用链的对象建立链接会被确定回收，

**引用类型分类**
强引用：代码之间显式的引用赋值，JVM 永远不会对其进行回收
软引用：允许内存在不足时被回收
弱引用：允许对象在没有强引用（即普通引用）指向它时被垃圾回收器回收。

### 垃圾收集算法

- 标记-清除（Mark-and-Sweep）算法分为“标记（Mark）”和“清除（Sweep）”阶段：首先标记出所有不需要回收的对象，在标记完成后统一回收掉所有没有被标记的对象
  问题：标记和清除两个过程效率都不高。且会产生大量内存碎片

- 复制算法：将内存分为大小相同的两块，每次使用一块内存区域，当其中一块使用完毕后将存活的对象复制到另一块中去。并把之前使用的内存区域清理。
  问题：实际可使用的内存变小，当存活对象数量较大时会产生性能问题。、
  ``
